unit proto.common; {125}

interface

// *********************************** 
//   classes for proto.common.proto
//   generated by ProtoBufGenerator 
//        kami-soft 2016-2017
// ***********************************

uses
  SysUtils,
  Classes,
  pbInput,
  pbOutput,
  pbPublic,
  uAbstractProtoBufClasses;

type
  TDomainTypeEnum=(
    DOMAIN_TRADING = 0,
    DOMAIN_SERVICES = 1,
    DOMAIN_GASOIL = 2,
    DOMAIN_HOTELS = 3,
    DOMAIN_TAXI = 4,
    DOMAIN_PARKING = 5
  );

  TOperationTypeEnum=(
    OPERATION_BUY = 0,
    OPERATION_BUY_RETURN = 1,
    OPERATION_SELL = 2,
    OPERATION_SELL_RETURN = 3
  );

  TPaymentTypeEnum=(
    PAYMENT_CASH = 0,
    PAYMENT_CARD = 1,
    PAYMENT_CREDIT = 2,
    PAYMENT_TARE = 3
  );

  TUserRoleEnum=(
    USER_ROLE_PAYMASTER = 1,
    USER_ROLE_CHIEF_PAYMASTER = 2,
    USER_ROLE_ADMINISTRATOR = 3
  );

  TTicketAdTypeEnum=(
    TICKET_AD_OFD = 0,
    TICKET_AD_ORG = 1,
    TICKET_AD_POS = 2,
    TICKET_AD_KKM = 3,
    TICKET_AD_INFO = 4
  );

  TDate = class(TAbstractProtoBufClass)
  public
    const tag_year = 1;
    const tag_month = 2;
    const tag_day = 3;
  strict private
    Fyear: Cardinal;
    Fmonth: Cardinal;
    Fday: Cardinal;

    procedure Setyear(Tag: Integer; const Value: Cardinal);
    procedure Setmonth(Tag: Integer; const Value: Cardinal);
    procedure Setday(Tag: Integer; const Value: Cardinal);
  strict protected
    function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
    procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
  public
    constructor Create; override;
    destructor Destroy; override;

    property year: Cardinal index tag_year read Fyear write Setyear;
    property month: Cardinal index tag_month read Fmonth write Setmonth;
    property day: Cardinal index tag_day read Fday write Setday;
  end;

  TTime = class(TAbstractProtoBufClass)
  public
    const tag_hour = 1;
    const tag_minute = 2;
    const tag_second = 3;
  strict private
    Fhour: Cardinal;
    Fminute: Cardinal;
    Fsecond: Cardinal;

    procedure Sethour(Tag: Integer; const Value: Cardinal);
    procedure Setminute(Tag: Integer; const Value: Cardinal);
    procedure Setsecond(Tag: Integer; const Value: Cardinal);
  strict protected
    function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
    procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
  public
    constructor Create; override;
    destructor Destroy; override;

    property hour: Cardinal index tag_hour read Fhour write Sethour;
    property minute: Cardinal index tag_minute read Fminute write Setminute;
    property second: Cardinal index tag_second read Fsecond write Setsecond;
  end;

  TDateTime = class(TAbstractProtoBufClass)
  public
    const tag_date = 1;
    const tag_time = 2;
  strict private
    Fdate: TDate;
    Ftime: TTime;

  strict protected
    function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
    procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
  public
    constructor Create; override;
    destructor Destroy; override;

    property date: TDate read Fdate;
    property time: TTime read Ftime;
  end;

  TMoney = class(TAbstractProtoBufClass)
  public
    const tag_bills = 1;
    const tag_coins = 2;
  strict private
    Fbills: UInt64;
    Fcoins: Cardinal;

    procedure Setbills(Tag: Integer; const Value: UInt64);
    procedure Setcoins(Tag: Integer; const Value: Cardinal);
  strict protected
    function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
    procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
  public
    constructor Create; override;
    destructor Destroy; override;

    property bills: UInt64 index tag_bills read Fbills write Setbills;
    property coins: Cardinal index tag_coins read Fcoins write Setcoins;
  end;

  TTicketAdInfo = class(TAbstractProtoBufClass)
  public
    const tag_type = 1;
    const tag_version = 2;
  strict private
    Ftype: TTicketAdTypeEnum;
    Fversion: UInt64;

    procedure Settype(Tag: Integer; const Value: TTicketAdTypeEnum);
    procedure Setversion(Tag: Integer; const Value: UInt64);
  strict protected
    function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
    procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
  public
    constructor Create; override;
    destructor Destroy; override;

    property &type: TTicketAdTypeEnum index tag_type read Ftype write Settype;
    property version: UInt64 index tag_version read Fversion write Setversion;
  end;

  TTicketAd = class(TAbstractProtoBufClass)
  public
    const tag_info = 1;
    const tag_text = 2;
  strict private
    Finfo: TTicketAdInfo;
    Ftext: string;

    procedure Settext(Tag: Integer; const Value: string);
  strict protected
    function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
    procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
  public
    constructor Create; override;
    destructor Destroy; override;

    property info: TTicketAdInfo read Finfo;
    property text: string index tag_text read Ftext write Settext;
  end;

  TKeyValuePair = class(TAbstractProtoBufClass)
  public
    const tag_key = 1;
    const tag_value = 2;
  strict private
    Fkey: string;
    Fvalue: string;

    procedure Setkey(Tag: Integer; const Value: string);
    procedure Setvalue(Tag: Integer; const Value: string);
  strict protected
    function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
    procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
  public
    constructor Create; override;
    destructor Destroy; override;

    property key: string index tag_key read Fkey write Setkey;
    property value: string index tag_value read Fvalue write Setvalue;
  end;

implementation

{ TDate }

constructor TDate.Create;
begin
  inherited;
  RegisterRequiredField(tag_year);
  RegisterRequiredField(tag_month);
  RegisterRequiredField(tag_day);
end;

destructor TDate.Destroy;
begin
  inherited;
end;

function TDate.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
  Result := inherited;
  if Result then
    Exit;
  Result := True;
  case FieldNumber of
    tag_year:
      year := ProtoBuf.readUInt32;
    tag_month:
      month := ProtoBuf.readUInt32;
    tag_day:
      day := ProtoBuf.readUInt32;
  else
    Result := False;
  end;
end;

procedure TDate.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
  inherited;
  if FieldHasValue[tag_year] then
    ProtoBuf.writeUInt32(tag_year, Fyear);
  if FieldHasValue[tag_month] then
    ProtoBuf.writeUInt32(tag_month, Fmonth);
  if FieldHasValue[tag_day] then
    ProtoBuf.writeUInt32(tag_day, Fday);
end;

procedure TDate.Setyear(Tag: Integer; const Value: Cardinal);
begin
  Fyear:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TDate.Setmonth(Tag: Integer; const Value: Cardinal);
begin
  Fmonth:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TDate.Setday(Tag: Integer; const Value: Cardinal);
begin
  Fday:= Value;
  FieldHasValue[Tag]:= True;
end;

{ TTime }

constructor TTime.Create;
begin
  inherited;
  RegisterRequiredField(tag_hour);
  RegisterRequiredField(tag_minute);
end;

destructor TTime.Destroy;
begin
  inherited;
end;

function TTime.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
  Result := inherited;
  if Result then
    Exit;
  Result := True;
  case FieldNumber of
    tag_hour:
      hour := ProtoBuf.readUInt32;
    tag_minute:
      minute := ProtoBuf.readUInt32;
    tag_second:
      second := ProtoBuf.readUInt32;
  else
    Result := False;
  end;
end;

procedure TTime.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
  inherited;
  if FieldHasValue[tag_hour] then
    ProtoBuf.writeUInt32(tag_hour, Fhour);
  if FieldHasValue[tag_minute] then
    ProtoBuf.writeUInt32(tag_minute, Fminute);
  if FieldHasValue[tag_second] then
    ProtoBuf.writeUInt32(tag_second, Fsecond);
end;

procedure TTime.Sethour(Tag: Integer; const Value: Cardinal);
begin
  Fhour:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TTime.Setminute(Tag: Integer; const Value: Cardinal);
begin
  Fminute:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TTime.Setsecond(Tag: Integer; const Value: Cardinal);
begin
  Fsecond:= Value;
  FieldHasValue[Tag]:= True;
end;

{ TDateTime }

constructor TDateTime.Create;
begin
  inherited;
  Fdate := TDate.Create;
  RegisterRequiredField(tag_date);
  Ftime := TTime.Create;
  RegisterRequiredField(tag_time);
end;

destructor TDateTime.Destroy;
begin
  Fdate.Free;
  Ftime.Free;
  inherited;
end;

function TDateTime.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
  tmpBuf: TProtoBufInput;
begin
  Result := inherited;
  if Result then
    Exit;
  Result := True;
  tmpBuf:= nil;
  try
    case FieldNumber of
      tag_date:
        begin
          tmpBuf := ProtoBuf.ReadSubProtoBufInput;
          Fdate.LoadFromBuf(tmpBuf);
        end;
      tag_time:
        begin
          tmpBuf := ProtoBuf.ReadSubProtoBufInput;
          Ftime.LoadFromBuf(tmpBuf);
        end;
    else
      Result := False;
    end;
  finally
    tmpBuf.Free
  end;
end;

procedure TDateTime.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
  tmpBuf: TProtoBufOutput;
begin
  inherited;
  tmpBuf:= TProtoBufOutput.Create;
  try
    if FieldHasValue[tag_date] then
      SaveMessageFieldToBuf(Fdate, tag_date, tmpBuf, ProtoBuf);
    if FieldHasValue[tag_time] then
      SaveMessageFieldToBuf(Ftime, tag_time, tmpBuf, ProtoBuf);
  finally
    tmpBuf.Free
  end;
end;

{ TMoney }

constructor TMoney.Create;
begin
  inherited;
  RegisterRequiredField(tag_bills);
  RegisterRequiredField(tag_coins);
end;

destructor TMoney.Destroy;
begin
  inherited;
end;

function TMoney.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
  Result := inherited;
  if Result then
    Exit;
  Result := True;
  case FieldNumber of
    tag_bills:
      bills := ProtoBuf.readInt64;
    tag_coins:
      coins := ProtoBuf.readUInt32;
  else
    Result := False;
  end;
end;

procedure TMoney.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
  inherited;
  if FieldHasValue[tag_bills] then
    ProtoBuf.writeInt64(tag_bills, Fbills);
  if FieldHasValue[tag_coins] then
    ProtoBuf.writeUInt32(tag_coins, Fcoins);
end;

procedure TMoney.Setbills(Tag: Integer; const Value: UInt64);
begin
  Fbills:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TMoney.Setcoins(Tag: Integer; const Value: Cardinal);
begin
  Fcoins:= Value;
  FieldHasValue[Tag]:= True;
end;

{ TTicketAdInfo }

constructor TTicketAdInfo.Create;
begin
  inherited;
  RegisterRequiredField(tag_type);
  RegisterRequiredField(tag_version);
end;

destructor TTicketAdInfo.Destroy;
begin
  inherited;
end;

function TTicketAdInfo.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
  Result := inherited;
  if Result then
    Exit;
  Result := True;
  case FieldNumber of
    tag_type:
      &type := TTicketAdTypeEnum(ProtoBuf.readEnum);
    tag_version:
      version := ProtoBuf.readInt64;
  else
    Result := False;
  end;
end;

procedure TTicketAdInfo.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
  inherited;
  if FieldHasValue[tag_type] then
    ProtoBuf.writeInt32(tag_type, Integer(Ftype));
  if FieldHasValue[tag_version] then
    ProtoBuf.writeInt64(tag_version, Fversion);
end;

procedure TTicketAdInfo.Settype(Tag: Integer; const Value: TTicketAdTypeEnum);
begin
  Ftype:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TTicketAdInfo.Setversion(Tag: Integer; const Value: UInt64);
begin
  Fversion:= Value;
  FieldHasValue[Tag]:= True;
end;

{ TTicketAd }

constructor TTicketAd.Create;
begin
  inherited;
  Finfo := TTicketAdInfo.Create;
  RegisterRequiredField(tag_info);
  RegisterRequiredField(tag_text);
end;

destructor TTicketAd.Destroy;
begin
  Finfo.Free;
  inherited;
end;

function TTicketAd.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
  tmpBuf: TProtoBufInput;
begin
  Result := inherited;
  if Result then
    Exit;
  Result := True;
  tmpBuf:= nil;
  try
    case FieldNumber of
      tag_info:
        begin
          tmpBuf := ProtoBuf.ReadSubProtoBufInput;
          Finfo.LoadFromBuf(tmpBuf);
        end;
      tag_text:
        text := ProtoBuf.readString;
    else
      Result := False;
    end;
  finally
    tmpBuf.Free
  end;
end;

procedure TTicketAd.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
  tmpBuf: TProtoBufOutput;
begin
  inherited;
  tmpBuf:= TProtoBufOutput.Create;
  try
    if FieldHasValue[tag_info] then
      SaveMessageFieldToBuf(Finfo, tag_info, tmpBuf, ProtoBuf);
    if FieldHasValue[tag_text] then
      ProtoBuf.writeString(tag_text, Ftext);
  finally
    tmpBuf.Free
  end;
end;

procedure TTicketAd.Settext(Tag: Integer; const Value: string);
begin
  Ftext:= Value;
  FieldHasValue[Tag]:= True;
end;

{ TKeyValuePair }

constructor TKeyValuePair.Create;
begin
  inherited;
  RegisterRequiredField(tag_key);
end;

destructor TKeyValuePair.Destroy;
begin
  inherited;
end;

function TKeyValuePair.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
  Result := inherited;
  if Result then
    Exit;
  Result := True;
  case FieldNumber of
    tag_key:
      key := ProtoBuf.readString;
    tag_value:
      value := ProtoBuf.readString;
  else
    Result := False;
  end;
end;

procedure TKeyValuePair.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
  inherited;
  if FieldHasValue[tag_key] then
    ProtoBuf.writeString(tag_key, Fkey);
  if FieldHasValue[tag_value] then
    ProtoBuf.writeString(tag_value, Fvalue);
end;

procedure TKeyValuePair.Setkey(Tag: Integer; const Value: string);
begin
  Fkey:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TKeyValuePair.Setvalue(Tag: Integer; const Value: string);
begin
  Fvalue:= Value;
  FieldHasValue[Tag]:= True;
end;

end.
