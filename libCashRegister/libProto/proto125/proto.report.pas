unit proto.report; { 125 }

interface

// ***********************************
// classes for proto.report.proto
// generated by ProtoBufGenerator
// kami-soft 2016-2017
// ***********************************

uses
    SysUtils,
    Classes,
    pbInput,
    pbOutput,
    pbPublic,
    uAbstractProtoBufClasses,
    proto.common,
    proto.ticket;

type
    TMoneyPlacementEnum = (MONEY_PLACEMENT_DEPOSIT = 0, MONEY_PLACEMENT_WITHDRAWAL = 1);

    TReportTypeEnum = (REPORT_Z = 0, REPORT_X = 1, REPORT_SECTIONS = 2, REPORT_OPERATORS = 3);


    TTaxOperation = class(TAbstractProtoBufClass)
    public const
        tag_operation = 1;
        tag_turnover = 2;
        tag_sum = 3;

    strict private
        Foperation: TOperationTypeEnum;
        Fturnover: TMoney;
        Fsum: TMoney;

        procedure Setoperation(Tag: Integer; const Value: TOperationTypeEnum);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property operation: TOperationTypeEnum index tag_operation read Foperation write Setoperation;
        property turnover: TMoney read Fturnover;
        property sum: TMoney read Fsum;
    end;


    TTax = class(TAbstractProtoBufClass)
    public const
        tag_tax_type = 1;
        tag_percent = 2;
        tag_operationsList = 3;

    strict private
        Ftax_type: Cardinal;
        Fpercent: Cardinal;

        procedure Settax_type(Tag: Integer; const Value: Cardinal);
        procedure Setpercent(Tag: Integer; const Value: Cardinal);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        operationsList: TArray<TTaxOperation>;
        constructor Create; override;
        destructor Destroy; override;

        property tax_type: Cardinal index tag_tax_type read Ftax_type write Settax_type;
        property percent: Cardinal index tag_percent read Fpercent write Setpercent;
    end;


    TOperation = class(TAbstractProtoBufClass)
    public const
        tag_operation = 1;
        tag_count = 2;
        tag_sum = 3;

    strict private
        Foperation: TOperationTypeEnum;
        Fcount: Cardinal;
        Fsum: TMoney;

        procedure Setoperation(Tag: Integer; const Value: TOperationTypeEnum);
        procedure Setcount(Tag: Integer; const Value: Cardinal);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property operation: TOperationTypeEnum index tag_operation read Foperation write Setoperation;
        property count: Cardinal index tag_count read Fcount write Setcount;
        property sum: TMoney read Fsum;
    end;


    TPayment = class(TAbstractProtoBufClass)
    public const
        tag_payment = 1;
        tag_sum = 2;
        tag_count = 3;

    strict private
        Fpayment: TPaymentTypeEnum;
        Fsum: TMoney;
        Fcount: Cardinal;

        procedure Setpayment(Tag: Integer; const Value: TPaymentTypeEnum);
        procedure Setcount(Tag: Integer; const Value: Cardinal);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property payment: TPaymentTypeEnum index tag_payment read Fpayment write Setpayment;
        property sum: TMoney read Fsum;
        property count: Cardinal index tag_count read Fcount write Setcount;
    end;


    TSection = class(TAbstractProtoBufClass)
    public const
        tag_section_code = 1;
        tag_operationsList = 2;

    strict private
        Fsection_code: string;

        procedure Setsection_code(Tag: Integer; const Value: string);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        operationsList: TArray<TOperation>;
        constructor Create; override;
        destructor Destroy; override;

        property section_code: string index tag_section_code read Fsection_code write Setsection_code;
    end;


    TNonNullableSum = class(TAbstractProtoBufClass)
    public const
        tag_operation = 1;
        tag_sum = 2;

    strict private
        Foperation: TOperationTypeEnum;
        Fsum: TMoney;

        procedure Setoperation(Tag: Integer; const Value: TOperationTypeEnum);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property operation: TOperationTypeEnum index tag_operation read Foperation write Setoperation;
        property sum: TMoney read Fsum;
    end;


    TTicketOperation = class(TAbstractProtoBufClass)
    public const
        tag_operation = 1;
        tag_tickets_total_count = 2;
        tag_tickets_count = 3;
        tag_tickets_sum = 4;
        tag_paymentsList = 5;
        tag_offline_count = 6;
        tag_discount_sum = 7;
        tag_markup_sum = 8;
        tag_change_sum = 9;

    strict private
        Foperation: TOperationTypeEnum;
        Ftickets_total_count: Cardinal;
        Ftickets_count: Cardinal;
        Ftickets_sum: TMoney;
        Foffline_count: Cardinal;
        Fdiscount_sum: TMoney;
        Fmarkup_sum: TMoney;
        Fchange_sum: TMoney;

        procedure Setoperation(Tag: Integer; const Value: TOperationTypeEnum);
        procedure Settickets_total_count(Tag: Integer; const Value: Cardinal);
        procedure Settickets_count(Tag: Integer; const Value: Cardinal);
        procedure Setoffline_count(Tag: Integer; const Value: Cardinal);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        paymentsList: TArray<TPayment>;
        constructor Create; override;
        destructor Destroy; override;

        property operation: TOperationTypeEnum index tag_operation read Foperation write Setoperation;
        property tickets_total_count: Cardinal index tag_tickets_total_count read Ftickets_total_count write Settickets_total_count;
        property tickets_count: Cardinal index tag_tickets_count read Ftickets_count write Settickets_count;
        property tickets_sum: TMoney read Ftickets_sum;
        property offline_count: Cardinal index tag_offline_count read Foffline_count write Setoffline_count;
        property discount_sum: TMoney read Fdiscount_sum;
        property markup_sum: TMoney read Fmarkup_sum;
        property change_sum: TMoney read Fchange_sum;
    end;


    TMoneyPlacement = class(TAbstractProtoBufClass)
    public const
        tag_operation = 1;
        tag_operations_total_count = 2;
        tag_operations_count = 3;
        tag_operations_sum = 4;
        tag_offline_count = 5;

    strict private
        Foperation: TMoneyPlacementEnum;
        Foperations_total_count: Cardinal;
        Foperations_count: Cardinal;
        Foperations_sum: TMoney;
        Foffline_count: Cardinal;

        procedure Setoperation(Tag: Integer; const Value: TMoneyPlacementEnum);
        procedure Setoperations_total_count(Tag: Integer; const Value: Cardinal);
        procedure Setoperations_count(Tag: Integer; const Value: Cardinal);
        procedure Setoffline_count(Tag: Integer; const Value: Cardinal);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property operation: TMoneyPlacementEnum index tag_operation read Foperation write Setoperation;
        property operations_total_count: Cardinal index tag_operations_total_count read Foperations_total_count write Setoperations_total_count;
        property operations_count: Cardinal index tag_operations_count read Foperations_count write Setoperations_count;
        property operations_sum: TMoney read Foperations_sum;
        property offline_count: Cardinal index tag_offline_count read Foffline_count write Setoffline_count;
    end;


    TAnnulledTickets = class(TAbstractProtoBufClass)
    public const
        tag_annulled_tickets_total_count = 1;
        tag_annulled_tickets_count = 2;
        tag_annulled_operationsList = 3;

    strict private
        Fannulled_tickets_total_count: Cardinal;
        Fannulled_tickets_count: Cardinal;

        procedure Setannulled_tickets_total_count(Tag: Integer; const Value: Cardinal);
        procedure Setannulled_tickets_count(Tag: Integer; const Value: Cardinal);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        annulled_operationsList: TArray<TOperation>;
        constructor Create; override;
        destructor Destroy; override;

        property annulled_tickets_total_count: Cardinal index tag_annulled_tickets_total_count read Fannulled_tickets_total_count write Setannulled_tickets_total_count;
        property annulled_tickets_count: Cardinal index tag_annulled_tickets_count read Fannulled_tickets_count write Setannulled_tickets_count;
    end;


    TRevenue = class(TAbstractProtoBufClass)
    public const
        tag_sum = 1;
        tag_is_negative = 2;

    strict private
        Fsum: TMoney;
        Fis_negative: Boolean;

        procedure Setis_negative(Tag: Integer; const Value: Boolean);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property sum: TMoney read Fsum;
        property is_negative: Boolean index tag_is_negative read Fis_negative write Setis_negative;
    end;


    TZXReport = class(TAbstractProtoBufClass)
    public const
        tag_date_time = 1;
        tag_shift_number = 2;
        tag_sectionsList = 3;
        tag_operationsList = 4;
        tag_discountsList = 5;
        tag_markupsList = 6;
        tag_total_resultList = 7;
        tag_taxesList = 8;
        tag_start_shift_non_nullable_sumsList = 9;
        tag_ticket_operationsList = 10;
        tag_money_placementsList = 11;
        tag_annulled_tickets = 12;
        tag_cash_sum = 13;
        tag_revenue = 14;
        tag_non_nullable_sumsList = 15;
        tag_open_shift_time = 16;
        tag_close_shift_time = 17;
        tag_checksum = 18;

    strict private
        Fdate_time: TDateTime;
        Fshift_number: Cardinal;
        Fannulled_tickets: TAnnulledTickets;
        Fcash_sum: TMoney;
        Frevenue: TRevenue;
        Fopen_shift_time: TDateTime;
        Fclose_shift_time: TDateTime;
        Fchecksum: string;

        procedure Setshift_number(Tag: Integer; const Value: Cardinal);
        procedure Setchecksum(Tag: Integer; const Value: string);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        sectionsList: TArray<TSection>;
        operationsList: TArray<TOperation>;
        discountsList: TArray<TOperation>;
        markupsList: TArray<TOperation>;
        total_resultList: TArray<TOperation>;
        taxesList: TArray<TTax>;
        start_shift_non_nullable_sumsList: TArray<TNonNullableSum>;
        ticket_operationsList: TArray<TTicketOperation>;
        money_placementsList: TArray<TMoneyPlacement>;
        non_nullable_sumsList: TArray<TNonNullableSum>;
        constructor Create; override;
        destructor Destroy; override;

        property date_time: TDateTime read Fdate_time;
        property shift_number: Cardinal index tag_shift_number read Fshift_number write Setshift_number;
        property annulled_tickets: TAnnulledTickets read Fannulled_tickets;
        property cash_sum: TMoney read Fcash_sum;
        property revenue: TRevenue read Frevenue;
        property open_shift_time: TDateTime read Fopen_shift_time;
        property close_shift_time: TDateTime read Fclose_shift_time;
        property checksum: string index tag_checksum read Fchecksum write Setchecksum;
    end;


    TMoneyPlacementRequest = class(TAbstractProtoBufClass)
    public const
        tag_datetime = 1;

    const
        tag_operation = 2;

    const
        tag_sum = 3;

    const
        tag_is_offline = 4;

    const
        tag_fr_shift_number = 5;

    const
        tag_shift_document_number = 6;
    strict private
        Fdatetime: TDateTime;
        Foperation: TMoneyPlacementEnum;
        Fsum: TMoney;
        Fis_offline: Boolean;
        Ffr_shift_number: Cardinal;
        Fshift_document_number: Cardinal;

        procedure Setoperation(Tag: Integer; const Value: TMoneyPlacementEnum);
        procedure Setis_offline(Tag: Integer; const Value: Boolean);
        procedure Setfr_shift_number(Tag: Integer; const Value: Cardinal);
        procedure Setshift_document_number(Tag: Integer; const Value: Cardinal);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property datetime: TDateTime read Fdatetime;
        property operation: TMoneyPlacementEnum index tag_operation read Foperation write Setoperation;
        property sum: TMoney read Fsum;
        property is_offline: Boolean index tag_is_offline read Fis_offline write Setis_offline;
        property fr_shift_number: Cardinal index tag_fr_shift_number read Ffr_shift_number write Setfr_shift_number;
        property shift_document_number: Cardinal index tag_shift_document_number read Fshift_document_number write Setshift_document_number;
    end;


    TCloseShiftRequest = class(TAbstractProtoBufClass)
    public const
        tag_close_time = 1;

    const
        tag_is_offline = 2;

    const
        tag_fr_shift_number = 3;

    const
        tag_withdraw_money = 4;

    const
        tag_z_report = 5;

    const
        tag_operator = 6;

    const
        tag_shift_document_number = 7;
    strict private
        Fclose_time: TDateTime;
        Fis_offline: Boolean;
        Ffr_shift_number: Cardinal;
        Fwithdraw_money: Boolean;
        Fz_report: TZXReport;
        Foperator: TOperator;
        Fshift_document_number: Cardinal;

        procedure Setis_offline(Tag: Integer; const Value: Boolean);
        procedure Setfr_shift_number(Tag: Integer; const Value: Cardinal);
        procedure Setwithdraw_money(Tag: Integer; const Value: Boolean);
        procedure Setoperator(Tag: Integer; const Value: TOperator);
        procedure Setshift_document_number(Tag: Integer; const Value: Cardinal);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property close_time: TDateTime read Fclose_time;
        property is_offline: Boolean index tag_is_offline read Fis_offline write Setis_offline;
        property fr_shift_number: Cardinal index tag_fr_shift_number read Ffr_shift_number write Setfr_shift_number;
        property withdraw_money: Boolean index tag_withdraw_money read Fwithdraw_money write Setwithdraw_money;
        property z_report: TZXReport read Fz_report;
        property &operator: TOperator index tag_operator read Foperator write Setoperator;
        property shift_document_number: Cardinal index tag_shift_document_number read Fshift_document_number write Setshift_document_number;
    end;


    TReportRequest = class(TAbstractProtoBufClass)
    public const
        tag_report = 1;

    const
        tag_date_time = 2;

    const
        tag_is_offline = 3;

    const
        tag_zx_report = 4;
    strict private
        Freport: TReportTypeEnum;
        Fdate_time: TDateTime;
        Fis_offline: Boolean;
        Fzx_report: TZXReport;

        procedure Setreport(Tag: Integer; const Value: TReportTypeEnum);
        procedure Setis_offline(Tag: Integer; const Value: Boolean);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property report: TReportTypeEnum index tag_report read Freport write Setreport;
        property date_time: TDateTime read Fdate_time;
        property is_offline: Boolean index tag_is_offline read Fis_offline write Setis_offline;
        property zx_report: TZXReport read Fzx_report;
    end;


    TReportResponse = class(TAbstractProtoBufClass)
    public const
        tag_report = 1;

    const
        tag_zx_report = 2;
    strict private
        Freport: TReportTypeEnum;
        Fzx_report: TZXReport;

        procedure Setreport(Tag: Integer; const Value: TReportTypeEnum);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property report: TReportTypeEnum index tag_report read Freport write Setreport;
        property zx_report: TZXReport read Fzx_report;
    end;

implementation

{ TTax }

uses
    proto.common.lists;


constructor TTax.Create;
begin
    inherited;
    RegisterRequiredField(tag_tax_type);
    RegisterRequiredField(tag_percent);
// FoperationsList := TArray<TTaxOperation>.Create;
end;


destructor TTax.Destroy;
begin
// FoperationsList.Free;
    inherited;
end;


function TTax.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    case FieldNumber of
        tag_tax_type:
            tax_type := ProtoBuf.readUInt32;
        tag_percent:
            percent := ProtoBuf.readUInt32;
        tag_operationsList:
            AddFromBufL(ProtoBuf, FieldNumber, operationsList);
        else
            Result := False;
    end;
end;


procedure TTax.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
    inherited;
    if FieldHasValue[tag_tax_type] then
        ProtoBuf.writeUInt32(tag_tax_type, Ftax_type);
    if FieldHasValue[tag_percent] then
        ProtoBuf.writeUInt32(tag_percent, Fpercent);
    if FieldHasValue[tag_operationsList] then
        SaveToBufL(ProtoBuf, tag_operationsList, operationsList);
end;


procedure TTax.Settax_type(Tag: Integer; const Value: Cardinal);
begin
    Ftax_type := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTax.Setpercent(Tag: Integer; const Value: Cardinal);
begin
    Fpercent := Value;
    FieldHasValue[Tag] := True;
end;

{ TZXReport }


constructor TZXReport.Create;
begin
    inherited;
    Fdate_time := TDateTime.Create;
    RegisterRequiredField(tag_date_time);
    RegisterRequiredField(tag_shift_number);
// FsectionsList := TArray<TSection>.Create;
// FoperationsList := TArray<TOperation>.Create;
// FdiscountsList := TArray<TOperation>.Create;
// FmarkupsList := TArray<TOperation>.Create;
// Ftotal_resultList := TArray<TOperation>.Create;
// FtaxesList := TArray<TTax>.Create;
// Fstart_shift_non_nullable_sumsList := TArray<TNonNullableSum>.Create;
// Fticket_operationsList := TArray<TTicketOperation>.Create;
// Fmoney_placementsList := TArray<TMoneyPlacement>.Create;
    Fannulled_tickets := TAnnulledTickets.Create;
    Fcash_sum := TMoney.Create;
    RegisterRequiredField(tag_cash_sum);
    Frevenue := TRevenue.Create;
    RegisterRequiredField(tag_revenue);
// Fnon_nullable_sumsList := TArray<TNonNullableSum>.Create;
    Fopen_shift_time := TDateTime.Create;
    Fclose_shift_time := TDateTime.Create;
end;


destructor TZXReport.Destroy;
begin
    Fdate_time.Free;
// FsectionsList.Free;
// FoperationsList.Free;
// FdiscountsList.Free;
// FmarkupsList.Free;
// Ftotal_resultList.Free;
// FtaxesList.Free;
// Fstart_shift_non_nullable_sumsList.Free;
// Fticket_operationsList.Free;
// Fmoney_placementsList.Free;
    Fannulled_tickets.Free;
    Fcash_sum.Free;
    Frevenue.Free;
// Fnon_nullable_sumsList.Free;
    Fopen_shift_time.Free;
    Fclose_shift_time.Free;
    inherited;
end;


function TZXReport.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_date_time:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fdate_time.LoadFromBuf(tmpBuf);
                end;
            tag_shift_number:
                shift_number := ProtoBuf.readUInt32;
            tag_sectionsList:
                AddFromBufL(ProtoBuf, FieldNumber, sectionsList);
            tag_operationsList:
                AddFromBufL(ProtoBuf, FieldNumber, operationsList);
            tag_discountsList:
                AddFromBufL(ProtoBuf, FieldNumber, discountsList);
            tag_markupsList:
                AddFromBufL(ProtoBuf, FieldNumber, markupsList);
            tag_total_resultList:
                AddFromBufL(ProtoBuf, FieldNumber, total_resultList);
            tag_taxesList:
                AddFromBufL(ProtoBuf, FieldNumber, taxesList);
            tag_start_shift_non_nullable_sumsList:
                AddFromBufL(ProtoBuf, FieldNumber, start_shift_non_nullable_sumsList);
            tag_ticket_operationsList:
                AddFromBufL(ProtoBuf, FieldNumber, ticket_operationsList);
            tag_money_placementsList:
                AddFromBufL(ProtoBuf, FieldNumber, money_placementsList);
            tag_annulled_tickets:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fannulled_tickets.LoadFromBuf(tmpBuf);
                end;
            tag_cash_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fcash_sum.LoadFromBuf(tmpBuf);
                end;
            tag_revenue:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Frevenue.LoadFromBuf(tmpBuf);
                end;
            tag_non_nullable_sumsList:
                AddFromBufL(ProtoBuf, FieldNumber, non_nullable_sumsList);
            tag_open_shift_time:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fopen_shift_time.LoadFromBuf(tmpBuf);
                end;
            tag_close_shift_time:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fclose_shift_time.LoadFromBuf(tmpBuf);
                end;
            tag_checksum:
                checksum := ProtoBuf.readString;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TZXReport.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_date_time] then
            SaveMessageFieldToBuf(Fdate_time, tag_date_time, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_shift_number] then
            ProtoBuf.writeUInt32(tag_shift_number, Fshift_number);
        if FieldHasValue[tag_sectionsList] then
            SaveToBufL(ProtoBuf, tag_sectionsList, sectionsList);
        if FieldHasValue[tag_operationsList] then
            SaveToBufL(ProtoBuf, tag_operationsList, operationsList);
        if FieldHasValue[tag_discountsList] then
            SaveToBufL(ProtoBuf, tag_discountsList, discountsList);
        if FieldHasValue[tag_markupsList] then
            SaveToBufL(ProtoBuf, tag_markupsList, markupsList);
        if FieldHasValue[tag_total_resultList] then
            SaveToBufL(ProtoBuf, tag_total_resultList, total_resultList);
        if FieldHasValue[tag_taxesList] then
            SaveToBufL(ProtoBuf, tag_taxesList, taxesList);
        if FieldHasValue[tag_start_shift_non_nullable_sumsList] then
            SaveToBufL(ProtoBuf, tag_start_shift_non_nullable_sumsList, start_shift_non_nullable_sumsList);
        if FieldHasValue[tag_ticket_operationsList] then
            SaveToBufL(ProtoBuf, tag_ticket_operationsList, ticket_operationsList);
        if FieldHasValue[tag_money_placementsList] then
            SaveToBufL(ProtoBuf, tag_money_placementsList, money_placementsList);
        if FieldHasValue[tag_annulled_tickets] then
            SaveMessageFieldToBuf(Fannulled_tickets, tag_annulled_tickets, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_cash_sum] then
            SaveMessageFieldToBuf(Fcash_sum, tag_cash_sum, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_revenue] then
            SaveMessageFieldToBuf(Frevenue, tag_revenue, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_non_nullable_sumsList] then
            SaveToBufL(ProtoBuf, tag_non_nullable_sumsList, non_nullable_sumsList);
        if FieldHasValue[tag_open_shift_time] then
            SaveMessageFieldToBuf(Fopen_shift_time, tag_open_shift_time, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_close_shift_time] then
            SaveMessageFieldToBuf(Fclose_shift_time, tag_close_shift_time, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_checksum] then
            ProtoBuf.writeString(tag_checksum, Fchecksum);
    finally
        tmpBuf.Free
    end;
end;


procedure TZXReport.Setshift_number(Tag: Integer; const Value: Cardinal);
begin
    Fshift_number := Value;
    FieldHasValue[Tag] := True;
end;


procedure TZXReport.Setchecksum(Tag: Integer; const Value: string);
begin
    Fchecksum := Value;
    FieldHasValue[Tag] := True;
end;

{ TMoneyPlacementRequest }


constructor TMoneyPlacementRequest.Create;
begin
    inherited;
    Fdatetime := TDateTime.Create;
    RegisterRequiredField(tag_datetime);
    RegisterRequiredField(tag_operation);
    Fsum := TMoney.Create;
    RegisterRequiredField(tag_sum);
end;


destructor TMoneyPlacementRequest.Destroy;
begin
    Fdatetime.Free;
    Fsum.Free;
    inherited;
end;


function TMoneyPlacementRequest.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_datetime:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fdatetime.LoadFromBuf(tmpBuf);
                end;
            tag_operation:
                operation := TMoneyPlacementEnum(ProtoBuf.readEnum);
            tag_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fsum.LoadFromBuf(tmpBuf);
                end;
            tag_is_offline:
                is_offline := ProtoBuf.readBoolean;
            tag_fr_shift_number:
                fr_shift_number := ProtoBuf.readUInt32;
            tag_shift_document_number:
                shift_document_number := ProtoBuf.readUInt32;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TMoneyPlacementRequest.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_datetime] then
            SaveMessageFieldToBuf(Fdatetime, tag_datetime, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_operation] then
            ProtoBuf.writeInt32(tag_operation, Integer(Foperation));
        if FieldHasValue[tag_sum] then
            SaveMessageFieldToBuf(Fsum, tag_sum, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_is_offline] then
            ProtoBuf.writeBoolean(tag_is_offline, Fis_offline);
        if FieldHasValue[tag_fr_shift_number] then
            ProtoBuf.writeUInt32(tag_fr_shift_number, Ffr_shift_number);
        if FieldHasValue[tag_shift_document_number] then
            ProtoBuf.writeUInt32(tag_shift_document_number, Fshift_document_number);
    finally
        tmpBuf.Free
    end;
end;


procedure TMoneyPlacementRequest.Setoperation(Tag: Integer; const Value: TMoneyPlacementEnum);
begin
    Foperation := Value;
    FieldHasValue[Tag] := True;
end;


procedure TMoneyPlacementRequest.Setis_offline(Tag: Integer; const Value: Boolean);
begin
    Fis_offline := Value;
    FieldHasValue[Tag] := True;
end;


procedure TMoneyPlacementRequest.Setfr_shift_number(Tag: Integer; const Value: Cardinal);
begin
    Ffr_shift_number := Value;
    FieldHasValue[Tag] := True;
end;


procedure TMoneyPlacementRequest.Setshift_document_number(Tag: Integer; const Value: Cardinal);
begin
    Fshift_document_number := Value;
    FieldHasValue[Tag] := True;
end;

{ TOperation }


constructor TOperation.Create;
begin
    inherited;
    RegisterRequiredField(tag_operation);
    RegisterRequiredField(tag_count);
    Fsum := TMoney.Create;
    RegisterRequiredField(tag_sum);
end;


destructor TOperation.Destroy;
begin
    Fsum.Free;
    inherited;
end;


function TOperation.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_operation:
                operation := TOperationTypeEnum(ProtoBuf.readEnum);
            tag_count:
                count := ProtoBuf.readUInt32;
            tag_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fsum.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TOperation.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_operation] then
            ProtoBuf.writeInt32(tag_operation, Integer(Foperation));
        if FieldHasValue[tag_count] then
            ProtoBuf.writeUInt32(tag_count, Fcount);
        if FieldHasValue[tag_sum] then
            SaveMessageFieldToBuf(Fsum, tag_sum, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;


procedure TOperation.Setoperation(Tag: Integer; const Value: TOperationTypeEnum);
begin
    Foperation := Value;
    FieldHasValue[Tag] := True;
end;


procedure TOperation.Setcount(Tag: Integer; const Value: Cardinal);
begin
    Fcount := Value;
    FieldHasValue[Tag] := True;
end;

{ TSection }


constructor TSection.Create;
begin
    inherited;
    RegisterRequiredField(tag_section_code);
//    FoperationsList := TArray<TOperation>.Create;
end;


destructor TSection.Destroy;
begin
//    FoperationsList.Free;
    inherited;
end;


function TSection.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    case FieldNumber of
        tag_section_code:
            section_code := ProtoBuf.readString;
        tag_operationsList:
            AddFromBufL(ProtoBuf, FieldNumber, operationsList);
        else
            Result := False;
    end;
end;


procedure TSection.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
    inherited;
    if FieldHasValue[tag_section_code] then
        ProtoBuf.writeString(tag_section_code, Fsection_code);
    if FieldHasValue[tag_operationsList] then
        SaveToBufL(ProtoBuf, tag_operationsList, operationsList);
end;


procedure TSection.Setsection_code(Tag: Integer; const Value: string);
begin
    Fsection_code := Value;
    FieldHasValue[Tag] := True;
end;

{ TTaxOperation }


constructor TTaxOperation.Create;
begin
    inherited;
    RegisterRequiredField(tag_operation);
    Fturnover := TMoney.Create;
    RegisterRequiredField(tag_turnover);
    Fsum := TMoney.Create;
    RegisterRequiredField(tag_sum);
end;


destructor TTaxOperation.Destroy;
begin
    Fturnover.Free;
    Fsum.Free;
    inherited;
end;


function TTaxOperation.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_operation:
                operation := TOperationTypeEnum(ProtoBuf.readEnum);
            tag_turnover:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fturnover.LoadFromBuf(tmpBuf);
                end;
            tag_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fsum.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TTaxOperation.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_operation] then
            ProtoBuf.writeInt32(tag_operation, Integer(Foperation));
        if FieldHasValue[tag_turnover] then
            SaveMessageFieldToBuf(Fturnover, tag_turnover, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_sum] then
            SaveMessageFieldToBuf(Fsum, tag_sum, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;


procedure TTaxOperation.Setoperation(Tag: Integer; const Value: TOperationTypeEnum);
begin
    Foperation := Value;
    FieldHasValue[Tag] := True;
end;

{ TPayment }


constructor TPayment.Create;
begin
    inherited;
    RegisterRequiredField(tag_payment);
    Fsum := TMoney.Create;
    RegisterRequiredField(tag_sum);
end;


destructor TPayment.Destroy;
begin
    Fsum.Free;
    inherited;
end;


function TPayment.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_payment:
                payment := TPaymentTypeEnum(ProtoBuf.readEnum);
            tag_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fsum.LoadFromBuf(tmpBuf);
                end;
            tag_count:
                count := ProtoBuf.readUInt32;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TPayment.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_payment] then
            ProtoBuf.writeInt32(tag_payment, Integer(Fpayment));
        if FieldHasValue[tag_sum] then
            SaveMessageFieldToBuf(Fsum, tag_sum, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_count] then
            ProtoBuf.writeUInt32(tag_count, Fcount);
    finally
        tmpBuf.Free
    end;
end;


procedure TPayment.Setpayment(Tag: Integer; const Value: TPaymentTypeEnum);
begin
    Fpayment := Value;
    FieldHasValue[Tag] := True;
end;


procedure TPayment.Setcount(Tag: Integer; const Value: Cardinal);
begin
    Fcount := Value;
    FieldHasValue[Tag] := True;
end;

{ TNonNullableSum }


constructor TNonNullableSum.Create;
begin
    inherited;
    RegisterRequiredField(tag_operation);
    Fsum := TMoney.Create;
    RegisterRequiredField(tag_sum);
end;


destructor TNonNullableSum.Destroy;
begin
    Fsum.Free;
    inherited;
end;


function TNonNullableSum.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_operation:
                operation := TOperationTypeEnum(ProtoBuf.readEnum);
            tag_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fsum.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TNonNullableSum.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_operation] then
            ProtoBuf.writeInt32(tag_operation, Integer(Foperation));
        if FieldHasValue[tag_sum] then
            SaveMessageFieldToBuf(Fsum, tag_sum, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;


procedure TNonNullableSum.Setoperation(Tag: Integer; const Value: TOperationTypeEnum);
begin
    Foperation := Value;
    FieldHasValue[Tag] := True;
end;

{ TTicketOperation }


constructor TTicketOperation.Create;
begin
    inherited;
    RegisterRequiredField(tag_operation);
    RegisterRequiredField(tag_tickets_total_count);
    RegisterRequiredField(tag_tickets_count);
    Ftickets_sum := TMoney.Create;
    RegisterRequiredField(tag_tickets_sum);
//    FpaymentsList := TArray<TPayment>.Create;
    Fdiscount_sum := TMoney.Create;
    Fmarkup_sum := TMoney.Create;
    Fchange_sum := TMoney.Create;
end;


destructor TTicketOperation.Destroy;
begin
    Ftickets_sum.Free;
//    FpaymentsList.Free;
    Fdiscount_sum.Free;
    Fmarkup_sum.Free;
    Fchange_sum.Free;
    inherited;
end;


function TTicketOperation.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_operation:
                operation := TOperationTypeEnum(ProtoBuf.readEnum);
            tag_tickets_total_count:
                tickets_total_count := ProtoBuf.readUInt32;
            tag_tickets_count:
                tickets_count := ProtoBuf.readUInt32;
            tag_tickets_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Ftickets_sum.LoadFromBuf(tmpBuf);
                end;
            tag_paymentsList:
                AddFromBufL(ProtoBuf, FieldNumber, paymentsList);
            tag_offline_count:
                offline_count := ProtoBuf.readUInt32;
            tag_discount_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fdiscount_sum.LoadFromBuf(tmpBuf);
                end;
            tag_markup_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fmarkup_sum.LoadFromBuf(tmpBuf);
                end;
            tag_change_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fchange_sum.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TTicketOperation.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_operation] then
            ProtoBuf.writeInt32(tag_operation, Integer(Foperation));
        if FieldHasValue[tag_tickets_total_count] then
            ProtoBuf.writeUInt32(tag_tickets_total_count, Ftickets_total_count);
        if FieldHasValue[tag_tickets_count] then
            ProtoBuf.writeUInt32(tag_tickets_count, Ftickets_count);
        if FieldHasValue[tag_tickets_sum] then
            SaveMessageFieldToBuf(Ftickets_sum, tag_tickets_sum, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_paymentsList] then
            SaveToBufL(ProtoBuf, tag_paymentsList, paymentsList);
        if FieldHasValue[tag_offline_count] then
            ProtoBuf.writeUInt32(tag_offline_count, Foffline_count);
        if FieldHasValue[tag_discount_sum] then
            SaveMessageFieldToBuf(Fdiscount_sum, tag_discount_sum, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_markup_sum] then
            SaveMessageFieldToBuf(Fmarkup_sum, tag_markup_sum, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_change_sum] then
            SaveMessageFieldToBuf(Fchange_sum, tag_change_sum, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;


procedure TTicketOperation.Setoperation(Tag: Integer; const Value: TOperationTypeEnum);
begin
    Foperation := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTicketOperation.Settickets_total_count(Tag: Integer; const Value: Cardinal);
begin
    Ftickets_total_count := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTicketOperation.Settickets_count(Tag: Integer; const Value: Cardinal);
begin
    Ftickets_count := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTicketOperation.Setoffline_count(Tag: Integer; const Value: Cardinal);
begin
    Foffline_count := Value;
    FieldHasValue[Tag] := True;
end;

{ TMoneyPlacement }


constructor TMoneyPlacement.Create;
begin
    inherited;
    RegisterRequiredField(tag_operation);
    RegisterRequiredField(tag_operations_total_count);
    RegisterRequiredField(tag_operations_count);
    Foperations_sum := TMoney.Create;
    RegisterRequiredField(tag_operations_sum);
end;


destructor TMoneyPlacement.Destroy;
begin
    Foperations_sum.Free;
    inherited;
end;


function TMoneyPlacement.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_operation:
                operation := TMoneyPlacementEnum(ProtoBuf.readEnum);
            tag_operations_total_count:
                operations_total_count := ProtoBuf.readUInt32;
            tag_operations_count:
                operations_count := ProtoBuf.readUInt32;
            tag_operations_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Foperations_sum.LoadFromBuf(tmpBuf);
                end;
            tag_offline_count:
                offline_count := ProtoBuf.readUInt32;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TMoneyPlacement.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_operation] then
            ProtoBuf.writeInt32(tag_operation, Integer(Foperation));
        if FieldHasValue[tag_operations_total_count] then
            ProtoBuf.writeUInt32(tag_operations_total_count, Foperations_total_count);
        if FieldHasValue[tag_operations_count] then
            ProtoBuf.writeUInt32(tag_operations_count, Foperations_count);
        if FieldHasValue[tag_operations_sum] then
            SaveMessageFieldToBuf(Foperations_sum, tag_operations_sum, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_offline_count] then
            ProtoBuf.writeUInt32(tag_offline_count, Foffline_count);
    finally
        tmpBuf.Free
    end;
end;


procedure TMoneyPlacement.Setoperation(Tag: Integer; const Value: TMoneyPlacementEnum);
begin
    Foperation := Value;
    FieldHasValue[Tag] := True;
end;


procedure TMoneyPlacement.Setoperations_total_count(Tag: Integer; const Value: Cardinal);
begin
    Foperations_total_count := Value;
    FieldHasValue[Tag] := True;
end;


procedure TMoneyPlacement.Setoperations_count(Tag: Integer; const Value: Cardinal);
begin
    Foperations_count := Value;
    FieldHasValue[Tag] := True;
end;


procedure TMoneyPlacement.Setoffline_count(Tag: Integer; const Value: Cardinal);
begin
    Foffline_count := Value;
    FieldHasValue[Tag] := True;
end;

{ TAnnulledTickets }


constructor TAnnulledTickets.Create;
begin
    inherited;
    RegisterRequiredField(tag_annulled_tickets_total_count);
    RegisterRequiredField(tag_annulled_tickets_count);
//    Fannulled_operationsList := TArray<TOperation>.Create;
end;


destructor TAnnulledTickets.Destroy;
begin
//    Fannulled_operationsList.Free;
    inherited;
end;


function TAnnulledTickets.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    case FieldNumber of
        tag_annulled_tickets_total_count:
            annulled_tickets_total_count := ProtoBuf.readUInt32;
        tag_annulled_tickets_count:
            annulled_tickets_count := ProtoBuf.readUInt32;
        tag_annulled_operationsList:
            AddFromBufL(ProtoBuf, FieldNumber, annulled_operationsList);
        else
            Result := False;
    end;
end;


procedure TAnnulledTickets.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
    inherited;
    if FieldHasValue[tag_annulled_tickets_total_count] then
        ProtoBuf.writeUInt32(tag_annulled_tickets_total_count, Fannulled_tickets_total_count);
    if FieldHasValue[tag_annulled_tickets_count] then
        ProtoBuf.writeUInt32(tag_annulled_tickets_count, Fannulled_tickets_count);
    if FieldHasValue[tag_annulled_operationsList] then
        SaveToBufL(ProtoBuf, tag_annulled_operationsList, annulled_operationsList);
end;


procedure TAnnulledTickets.Setannulled_tickets_total_count(Tag: Integer; const Value: Cardinal);
begin
    Fannulled_tickets_total_count := Value;
    FieldHasValue[Tag] := True;
end;


procedure TAnnulledTickets.Setannulled_tickets_count(Tag: Integer; const Value: Cardinal);
begin
    Fannulled_tickets_count := Value;
    FieldHasValue[Tag] := True;
end;

{ TRevenue }


constructor TRevenue.Create;
begin
    inherited;
    Fsum := TMoney.Create;
    RegisterRequiredField(tag_sum);
    RegisterRequiredField(tag_is_negative);
end;


destructor TRevenue.Destroy;
begin
    Fsum.Free;
    inherited;
end;


function TRevenue.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fsum.LoadFromBuf(tmpBuf);
                end;
            tag_is_negative:
                is_negative := ProtoBuf.readBoolean;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TRevenue.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_sum] then
            SaveMessageFieldToBuf(Fsum, tag_sum, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_is_negative] then
            ProtoBuf.writeBoolean(tag_is_negative, Fis_negative);
    finally
        tmpBuf.Free
    end;
end;


procedure TRevenue.Setis_negative(Tag: Integer; const Value: Boolean);
begin
    Fis_negative := Value;
    FieldHasValue[Tag] := True;
end;

{ TCloseShiftRequest }


constructor TCloseShiftRequest.Create;
begin
    inherited;
    Fclose_time := TDateTime.Create;
    RegisterRequiredField(tag_close_time);
    Foperator := TOperator.Create;
    RegisterRequiredField(tag_operator);
    Fz_report := TZXReport.Create;
end;


destructor TCloseShiftRequest.Destroy;
begin
    Fclose_time.Free;
    Fz_report.Free;
    inherited;
end;


function TCloseShiftRequest.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_close_time:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fclose_time.LoadFromBuf(tmpBuf);
                end;
            tag_is_offline:
                is_offline := ProtoBuf.readBoolean;
            tag_fr_shift_number:
                fr_shift_number := ProtoBuf.readUInt32;
            tag_withdraw_money:
                withdraw_money := ProtoBuf.readBoolean;
            tag_z_report:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fz_report.LoadFromBuf(tmpBuf);
                end;
            tag_operator:
                begin
// &operator := TOperator(ProtoBuf.readEnum);
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Foperator.LoadFromBuf(tmpBuf);
                end;
            tag_shift_document_number:
                shift_document_number := ProtoBuf.readUInt32;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TCloseShiftRequest.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_close_time] then
            SaveMessageFieldToBuf(Fclose_time, tag_close_time, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_is_offline] then
            ProtoBuf.writeBoolean(tag_is_offline, Fis_offline);
        if FieldHasValue[tag_fr_shift_number] then
            ProtoBuf.writeUInt32(tag_fr_shift_number, Ffr_shift_number);
        if FieldHasValue[tag_withdraw_money] then
            ProtoBuf.writeBoolean(tag_withdraw_money, Fwithdraw_money);
        if FieldHasValue[tag_z_report] then
            SaveMessageFieldToBuf(Fz_report, tag_z_report, tmpBuf, ProtoBuf);
// if FieldHasValue[tag_operator] then
// ProtoBuf.writeInt32(tag_operator, Integer(Foperator));
        if FieldHasValue[tag_operator] then
            SaveMessageFieldToBuf(Foperator, tag_operator, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_shift_document_number] then
            ProtoBuf.writeUInt32(tag_shift_document_number, Fshift_document_number);
    finally
        tmpBuf.Free
    end;
end;


procedure TCloseShiftRequest.Setis_offline(Tag: Integer; const Value: Boolean);
begin
    Fis_offline := Value;
    FieldHasValue[Tag] := True;
end;


procedure TCloseShiftRequest.Setfr_shift_number(Tag: Integer; const Value: Cardinal);
begin
    Ffr_shift_number := Value;
    FieldHasValue[Tag] := True;
end;


procedure TCloseShiftRequest.Setwithdraw_money(Tag: Integer; const Value: Boolean);
begin
    Fwithdraw_money := Value;
    FieldHasValue[Tag] := True;
end;


procedure TCloseShiftRequest.Setoperator(Tag: Integer; const Value: TOperator);
begin
    Foperator := Value;
    FieldHasValue[Tag] := True;
end;


procedure TCloseShiftRequest.Setshift_document_number(Tag: Integer; const Value: Cardinal);
begin
    Fshift_document_number := Value;
    FieldHasValue[Tag] := True;
end;

{ TReportRequest }


constructor TReportRequest.Create;
begin
    inherited;
    RegisterRequiredField(tag_report);
    Fdate_time := TDateTime.Create;
    RegisterRequiredField(tag_date_time);
    Fzx_report := TZXReport.Create;
end;


destructor TReportRequest.Destroy;
begin
    Fdate_time.Free;
    Fzx_report.Free;
    inherited;
end;


function TReportRequest.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_report:
                report := TReportTypeEnum(ProtoBuf.readEnum);
            tag_date_time:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fdate_time.LoadFromBuf(tmpBuf);
                end;
            tag_is_offline:
                is_offline := ProtoBuf.readBoolean;
            tag_zx_report:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fzx_report.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TReportRequest.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_report] then
            ProtoBuf.writeInt32(tag_report, Integer(Freport));
        if FieldHasValue[tag_date_time] then
            SaveMessageFieldToBuf(Fdate_time, tag_date_time, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_is_offline] then
            ProtoBuf.writeBoolean(tag_is_offline, Fis_offline);
        if FieldHasValue[tag_zx_report] then
            SaveMessageFieldToBuf(Fzx_report, tag_zx_report, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;


procedure TReportRequest.Setreport(Tag: Integer; const Value: TReportTypeEnum);
begin
    Freport := Value;
    FieldHasValue[Tag] := True;
end;


procedure TReportRequest.Setis_offline(Tag: Integer; const Value: Boolean);
begin
    Fis_offline := Value;
    FieldHasValue[Tag] := True;
end;

{ TReportResponse }


constructor TReportResponse.Create;
begin
    inherited;
    RegisterRequiredField(tag_report);
    Fzx_report := TZXReport.Create;
end;


destructor TReportResponse.Destroy;
begin
    Fzx_report.Free;
    inherited;
end;


function TReportResponse.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_report:
                report := TReportTypeEnum(ProtoBuf.readEnum);
            tag_zx_report:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fzx_report.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TReportResponse.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_report] then
            ProtoBuf.writeInt32(tag_report, Integer(Freport));
        if FieldHasValue[tag_zx_report] then
            SaveMessageFieldToBuf(Fzx_report, tag_zx_report, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;


procedure TReportResponse.Setreport(Tag: Integer; const Value: TReportTypeEnum);
begin
    Freport := Value;
    FieldHasValue[Tag] := True;
end;

end.
