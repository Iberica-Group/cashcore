unit proto.ticket; { 125 }

interface

// ***********************************
// classes for proto.ticket.proto
// generated by ProtoBufGenerator
// kami-soft 2016-2017
// ***********************************

uses
    SysUtils,
    Classes,
    pbInput,
    pbOutput,
    pbPublic,
    uAbstractProtoBufClasses,
    proto.common;

type
    TItemTypeEnum = (
         item_type_unset = 0,
         ITEM_TYPE_COMMODITY = 1,
         ITEM_TYPE_STORNO_COMMODITY = 2,
         ITEM_TYPE_MARKUP = 3,
         ITEM_TYPE_STORNO_MARKUP = 4,
         ITEM_TYPE_DISCOUNT = 5,
         ITEM_TYPE_STORNO_DISCOUNT = 6
         );


    TTax = class(TAbstractProtoBufClass)
    public
         const
        tag_tax_type = 1;

    const
        tag_taxation_type = 2;

    const
        tag_percent = 3;

    const
        tag_sum = 4;

    const
        tag_is_in_total_sum = 5;
    strict private
        Ftax_type: Cardinal;
        Ftaxation_type: Cardinal;
        Fpercent: Cardinal;
        Fsum: TMoney;
        Fis_in_total_sum: Boolean;

        procedure Settax_type(Tag: Integer; const Value: Cardinal);
        procedure Settaxation_type(Tag: Integer; const Value: Cardinal);
        procedure Setpercent(Tag: Integer; const Value: Cardinal);
        procedure Setis_in_total_sum(Tag: Integer; const Value: Boolean);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property tax_type: Cardinal index tag_tax_type read Ftax_type write Settax_type;
        property taxation_type: Cardinal index tag_taxation_type read Ftaxation_type write Settaxation_type;
        property percent: Cardinal index tag_percent read Fpercent write Setpercent;
        property sum: TMoney read Fsum;
        property is_in_total_sum: Boolean index tag_is_in_total_sum read Fis_in_total_sum write Setis_in_total_sum;
    end;


    TModifier = class(TAbstractProtoBufClass)
    public
         const
        tag_name = 1;

    const
        tag_sum = 2;

    const
        tag_taxesList = 3;

    const
        tag_auxiliaryList = 4;
    strict private
        Fname: string;
        Fsum: TMoney;

        procedure Setname(Tag: Integer; const Value: string);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        taxesList: TArray<TTax>;
        auxiliaryList: TArray<TKeyValuePair>;
        constructor Create; override;
        destructor Destroy; override;

        property name: string index tag_name read Fname write Setname;
        property sum: TMoney read Fsum;
    end;


    TOperator = class(TAbstractProtoBufClass)
    public
         const
        tag_code = 1;

    const
        tag_name = 2;
    strict private
        Fcode: Cardinal;
        Fname: string;

        procedure Setcode(Tag: Integer; const Value: Cardinal);
        procedure Setname(Tag: Integer; const Value: string);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property code: Cardinal index tag_code read Fcode write Setcode;
        property name: string index tag_name read Fname write Setname;
    end;


    TCommodity = class(TAbstractProtoBufClass)
    public
         const
        tag_code = 1;

    const
        tag_name = 2;

    const
        tag_section_code = 3;

    const
        tag_quantity = 4;

    const
        tag_price = 5;

    const
        tag_sum = 6;

    const
        tag_taxesList = 7;

    const
        tag_excise_stamp = 8;

    const
        tag_auxiliaryList = 9;
    strict private
        Fcode: Cardinal;
        Fname: string;
        Fsection_code: string;
        Fquantity: Cardinal;
        Fprice: TMoney;
        Fsum: TMoney;
        Fexcise_stamp: string;

        procedure Setcode(Tag: Integer; const Value: Cardinal);
        procedure Setname(Tag: Integer; const Value: string);
        procedure Setsection_code(Tag: Integer; const Value: string);
        procedure Setquantity(Tag: Integer; const Value: Cardinal);
        procedure Setexcise_stamp(Tag: Integer; const Value: string);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        taxesList: TArray<TTax>;
        auxiliaryList: TArray<TKeyValuePair>;
        constructor Create; override;
        destructor Destroy; override;

        property code: Cardinal index tag_code read Fcode write Setcode;
        property name: string index tag_name read Fname write Setname;
        property section_code: string index tag_section_code read Fsection_code write Setsection_code;
        property quantity: Cardinal index tag_quantity read Fquantity write Setquantity;
        property price: TMoney read Fprice;
        property sum: TMoney read Fsum;
        property excise_stamp: string index tag_excise_stamp read Fexcise_stamp write Setexcise_stamp;
    end;


    TStornoCommodity = class(TAbstractProtoBufClass)
    public
         const
        tag_name = 1;

    const
        tag_section_code = 2;

    const
        tag_quantity = 3;

    const
        tag_price = 4;

    const
        tag_sum = 5;

    const
        tag_taxesList = 6;

    const
        tag_excise_stamp = 7;

    const
        tag_auxiliaryList = 8;
    strict private
        Fname: string;
        Fsection_code: string;
        Fquantity: Cardinal;
        Fprice: TMoney;
        Fsum: TMoney;
        Fexcise_stamp: string;

        procedure Setname(Tag: Integer; const Value: string);
        procedure Setsection_code(Tag: Integer; const Value: string);
        procedure Setquantity(Tag: Integer; const Value: Cardinal);
        procedure Setexcise_stamp(Tag: Integer; const Value: string);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        taxesList: TArray<TTax>;
        auxiliaryList: TArray<TKeyValuePair>;
        constructor Create; override;
        destructor Destroy; override;

        property name: string index tag_name read Fname write Setname;
        property section_code: string index tag_section_code read Fsection_code write Setsection_code;
        property quantity: Cardinal index tag_quantity read Fquantity write Setquantity;
        property price: TMoney read Fprice;
        property sum: TMoney read Fsum;
        property excise_stamp: string index tag_excise_stamp read Fexcise_stamp write Setexcise_stamp;
    end;


    TItem = class(TAbstractProtoBufClass)
    public
         const
        tag_type = 1;

    const
        tag_commodity = 2;

    const
        tag_storno_commodity = 3;

    const
        tag_markup = 4;

    const
        tag_storno_markup = 5;

    const
        tag_discount = 6;

    const
        tag_storno_discount = 7;
    strict private
        Ftype: TItemTypeEnum;
        Fcommodity: TCommodity;
        Fstorno_commodity: TStornoCommodity;
        Fmarkup: TModifier;
        Fstorno_markup: TModifier;
        Fdiscount: TModifier;
        Fstorno_discount: TModifier;

        procedure Settype(Tag: Integer; const Value: TItemTypeEnum);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property &type: TItemTypeEnum index tag_type read Ftype write Settype;
        property commodity: TCommodity read Fcommodity;
        property storno_commodity: TStornoCommodity read Fstorno_commodity;
        property markup: TModifier read Fmarkup;
        property storno_markup: TModifier read Fstorno_markup;
        property discount: TModifier read Fdiscount;
        property storno_discount: TModifier read Fstorno_discount;
    end;


    TServices = class(TAbstractProtoBufClass)
    public
         const
        tag_account_number = 1;
    strict private
        Faccount_number: string;

        procedure Setaccount_number(Tag: Integer; const Value: string);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property account_number: string index tag_account_number read Faccount_number write Setaccount_number;
    end;


    TGasOil = class(TAbstractProtoBufClass)
    public
         const
        tag_correction_number = 1;

    const
        tag_correction_sum = 2;

    const
        tag_card_number = 3;
    strict private
        Fcorrection_number: string;
        Fcorrection_sum: TMoney;
        Fcard_number: string;

        procedure Setcorrection_number(Tag: Integer; const Value: string);
        procedure Setcard_number(Tag: Integer; const Value: string);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property correction_number: string index tag_correction_number read Fcorrection_number write Setcorrection_number;
        property correction_sum: TMoney read Fcorrection_sum;
        property card_number: string index tag_card_number read Fcard_number write Setcard_number;
    end;


    TTaxi = class(TAbstractProtoBufClass)
    public
         const
        tag_car_number = 1;

    const
        tag_is_order = 2;

    const
        tag_current_fee = 3;
    strict private
        Fcar_number: string;
        Fis_order: Boolean;
        Fcurrent_fee: TMoney;

        procedure Setcar_number(Tag: Integer; const Value: string);
        procedure Setis_order(Tag: Integer; const Value: Boolean);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property car_number: string index tag_car_number read Fcar_number write Setcar_number;
        property is_order: Boolean index tag_is_order read Fis_order write Setis_order;
        property current_fee: TMoney read Fcurrent_fee;
    end;


    TParking = class(TAbstractProtoBufClass)
    public
         const
        tag_begin_time = 1;

    const
        tag_end_time = 2;
    strict private
        Fbegin_time: TDateTime;
        Fend_time: TDateTime;

    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property begin_time: TDateTime read Fbegin_time;
        property end_time: TDateTime read Fend_time;
    end;


    TDomain = class(TAbstractProtoBufClass)
    public
         const
        tag_type = 1;

    const
        tag_services = 2;

    const
        tag_gasoil = 3;

    const
        tag_taxi = 4;

    const
        tag_parking = 5;
    strict private
        Ftype: TDomainTypeEnum;
        Fservices: TServices;
        Fgasoil: TGasOil;
        Ftaxi: TTaxi;
        Fparking: TParking;

        procedure Settype(Tag: Integer; const Value: TDomainTypeEnum);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property &type: TDomainTypeEnum index tag_type read Ftype write Settype;
        property services: TServices read Fservices;
        property gasoil: TGasOil read Fgasoil;
        property taxi: TTaxi read Ftaxi;
        property parking: TParking read Fparking;
    end;


    TExtensionOptions = class(TAbstractProtoBufClass)
    public
         const
        tag_customer_email = 1;

    const
        tag_customer_phone = 2;

    const
        tag_auxiliaryList = 3;
    strict private
        Fcustomer_email: string;
        Fcustomer_phone: string;

        procedure Setcustomer_email(Tag: Integer; const Value: string);
        procedure Setcustomer_phone(Tag: Integer; const Value: string);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        auxiliaryList: TArray<TKeyValuePair>;
        constructor Create; override;
        destructor Destroy; override;

        property customer_email: string index tag_customer_email read Fcustomer_email write Setcustomer_email;
        property customer_phone: string index tag_customer_phone read Fcustomer_phone write Setcustomer_phone;
    end;


    TPayment = class(TAbstractProtoBufClass)
    public
         const
        tag_type = 1;

    const
        tag_sum = 2;
    strict private
        Ftype: TPaymentTypeEnum;
        Fsum: TMoney;

        procedure Settype(Tag: Integer; const Value: TPaymentTypeEnum);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property &type: TPaymentTypeEnum index tag_type read Ftype write Settype;
        property sum: TMoney read Fsum;
    end;


    TAmounts = class(TAbstractProtoBufClass)
    public
         const
        tag_total = 1;

    const
        tag_taken = 2;

    const
        tag_change = 3;

    const
        tag_markup = 4;

    const
        tag_discount = 5;
    strict private
        Ftotal: TMoney;
        Ftaken: TMoney;
        Fchange: TMoney;
        Fmarkup: TModifier;
        Fdiscount: TModifier;

    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property total: TMoney read Ftotal;
        property taken: TMoney read Ftaken;
        property change: TMoney read Fchange;
        property markup: TModifier read Fmarkup write Fmarkup;
        property discount: TModifier read Fdiscount write Fdiscount;
    end;


    TTicketRequest = class(TAbstractProtoBufClass)
    public
         const
        tag_operation = 1;

    const
        tag_date_time = 2;

    const
        tag_operator = 3;

    const
        tag_domain = 4;

    const
        tag_itemsList = 5;

    const
        tag_paymentsList = 6;

    const
        tag_taxesList = 7;

    const
        tag_amounts = 8;

    const
        tag_extension_options = 9;

    const
        tag_offline_ticket_number = 10;

    const
        tag_printed_document_number = 11;

    const
        tag_printed_ticket = 12;

    const
        tag_ad_infosList = 13;

    const
        tag_fr_shift_number = 14;

    const
        tag_shift_document_number = 15;
    strict private
        Foperation: TOperationTypeEnum;
        Fdate_time: TDateTime;
        Foperator: TOperator;
        Fdomain: TDomain;
        Famounts: TAmounts;
        Fextension_options: TExtensionOptions;
        Foffline_ticket_number: Cardinal;
        Fprinted_document_number: string;
        Fprinted_ticket: string;
        Ffr_shift_number: Cardinal;
        Fshift_document_number: Cardinal;

        procedure Setoperation(Tag: Integer; const Value: TOperationTypeEnum);
        procedure Setoffline_ticket_number(Tag: Integer; const Value: Cardinal);
        procedure Setprinted_document_number(Tag: Integer; const Value: string);
        procedure Setprinted_ticket(Tag: Integer; const Value: string);
        procedure Setfr_shift_number(Tag: Integer; const Value: Cardinal);
        procedure Setshift_document_number(Tag: Integer; const Value: Cardinal);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        itemsList: TArray<TItem>;
        paymentsList: TArray<TPayment>;
        taxesList: TArray<TTax>;
        ad_infosList: TArray<TTicketAdInfo>;
        constructor Create; override;
        destructor Destroy; override;

        property operation: TOperationTypeEnum index tag_operation read Foperation write Setoperation;
        property date_time: TDateTime read Fdate_time;
        property &operator: TOperator read Foperator;
        property domain: TDomain read Fdomain;
        property amounts: TAmounts read Famounts write Famounts;
        property extension_options: TExtensionOptions read Fextension_options;
        property offline_ticket_number: Cardinal index tag_offline_ticket_number read Foffline_ticket_number write Setoffline_ticket_number;
        property printed_document_number: string index tag_printed_document_number read Fprinted_document_number write Setprinted_document_number;
        property printed_ticket: string index tag_printed_ticket read Fprinted_ticket write Setprinted_ticket;
        property fr_shift_number: Cardinal index tag_fr_shift_number read Ffr_shift_number write Setfr_shift_number;
        property shift_document_number: Cardinal index tag_shift_document_number read Fshift_document_number write Setshift_document_number;
    end;


    TTicketResponse = class(TAbstractProtoBufClass)
    public
         const
        tag_ticket_number = 1;

    const
        tag_qr_code = 2;
    strict private
        Fticket_number: string;
        Fqr_code: TBytes;

        procedure Setticket_number(Tag: Integer; const Value: string);
        procedure Setqr_code(Tag: Integer; const Value: TBytes);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property ticket_number: string index tag_ticket_number read Fticket_number write Setticket_number;
        property qr_code: TBytes index tag_qr_code read Fqr_code write Setqr_code;
    end;

implementation

uses
    proto.common.lists;

{ TTax }


constructor TTax.Create;
begin
    inherited;
    RegisterRequiredField(tag_tax_type);
    RegisterRequiredField(tag_taxation_type);
    RegisterRequiredField(tag_percent);
    Fsum := TMoney.Create;
    RegisterRequiredField(tag_sum);
    RegisterRequiredField(tag_is_in_total_sum);
end;


destructor TTax.Destroy;
begin
    Fsum.Free;
    inherited;
end;


function TTax.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_tax_type:
                tax_type := ProtoBuf.readUInt32;
            tag_taxation_type:
                taxation_type := ProtoBuf.readUInt32;
            tag_percent:
                percent := ProtoBuf.readUInt32;
            tag_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fsum.LoadFromBuf(tmpBuf);
                end;
            tag_is_in_total_sum:
                is_in_total_sum := ProtoBuf.readBoolean;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TTax.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_tax_type] then
            ProtoBuf.writeUInt32(tag_tax_type, Ftax_type);
        if FieldHasValue[tag_taxation_type] then
            ProtoBuf.writeUInt32(tag_taxation_type, Ftaxation_type);
        if FieldHasValue[tag_percent] then
            ProtoBuf.writeUInt32(tag_percent, Fpercent);
        if FieldHasValue[tag_sum] then
            SaveMessageFieldToBuf(Fsum, tag_sum, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_is_in_total_sum] then
            ProtoBuf.writeBoolean(tag_is_in_total_sum, Fis_in_total_sum);
    finally
        tmpBuf.Free
    end;
end;


procedure TTax.Settax_type(Tag: Integer; const Value: Cardinal);
begin
    Ftax_type := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTax.Settaxation_type(Tag: Integer; const Value: Cardinal);
begin
    Ftaxation_type := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTax.Setpercent(Tag: Integer; const Value: Cardinal);
begin
    Fpercent := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTax.Setis_in_total_sum(Tag: Integer; const Value: Boolean);
begin
    Fis_in_total_sum := Value;
    FieldHasValue[Tag] := True;
end;

{ TModifier }


constructor TModifier.Create;
begin
    inherited;
    Fsum := TMoney.Create;
    RegisterRequiredField(tag_sum);
// FtaxesList := TArray<TTax>.Create;
// FauxiliaryList := TArray<TKeyValuePair>.Create;
end;


destructor TModifier.Destroy;
begin
    Fsum.Free;
// FtaxesList.Free;
// FauxiliaryList.Free;
    inherited;
end;


function TModifier.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_name:
                name := ProtoBuf.readString;
            tag_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fsum.LoadFromBuf(tmpBuf);
                end;
            tag_taxesList:
                AddFromBufL(ProtoBuf, FieldNumber, taxesList);
            tag_auxiliaryList:
                AddFromBufL(ProtoBuf, FieldNumber, auxiliaryList);
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TModifier.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_name] then
            ProtoBuf.writeString(tag_name, Fname);
        if FieldHasValue[tag_sum] then
            SaveMessageFieldToBuf(Fsum, tag_sum, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_taxesList] then
            SaveToBufL(ProtoBuf, tag_taxesList, taxesList);
        if FieldHasValue[tag_auxiliaryList] then
            SaveToBufL(ProtoBuf, tag_auxiliaryList, auxiliaryList);
    finally
        tmpBuf.Free
    end;
end;


procedure TModifier.Setname(Tag: Integer; const Value: string);
begin
    Fname := Value;
    FieldHasValue[Tag] := True;
end;

{ TOperator }


constructor TOperator.Create;
begin
    inherited;
    RegisterRequiredField(tag_code);
end;


destructor TOperator.Destroy;
begin
    inherited;
end;


function TOperator.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    case FieldNumber of
        tag_code:
            code := ProtoBuf.readUInt32;
        tag_name:
            name := ProtoBuf.readString;
        else
            Result := False;
    end;
end;


procedure TOperator.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
    inherited;
    if FieldHasValue[tag_code] then
        ProtoBuf.writeUInt32(tag_code, Fcode);
    if FieldHasValue[tag_name] then
        ProtoBuf.writeString(tag_name, Fname);
end;


procedure TOperator.Setcode(Tag: Integer; const Value: Cardinal);
begin
    Fcode := Value;
    FieldHasValue[Tag] := True;
end;


procedure TOperator.Setname(Tag: Integer; const Value: string);
begin
    Fname := Value;
    FieldHasValue[Tag] := True;
end;

{ TCommodity }


constructor TCommodity.Create;
begin
    inherited;
    RegisterRequiredField(tag_section_code);
    RegisterRequiredField(tag_quantity);
    Fprice := TMoney.Create;
    RegisterRequiredField(tag_price);
    Fsum := TMoney.Create;
    RegisterRequiredField(tag_sum);
// FtaxesList := TArray<TTax>.Create;
// FauxiliaryList := TArray<TKeyValuePair>.Create;
end;


destructor TCommodity.Destroy;
begin
    Fprice.Free;
    Fsum.Free;
// FtaxesList.Free;
// FauxiliaryList.Free;
    inherited;
end;


function TCommodity.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_code:
                code := ProtoBuf.readUInt32;
            tag_name:
                name := ProtoBuf.readString;
            tag_section_code:
                section_code := ProtoBuf.readString;
            tag_quantity:
                quantity := ProtoBuf.readUInt32;
            tag_price:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fprice.LoadFromBuf(tmpBuf);
                end;
            tag_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fsum.LoadFromBuf(tmpBuf);
                end;
            tag_taxesList:
                AddFromBufL(ProtoBuf, FieldNumber, taxesList);
            tag_excise_stamp:
                excise_stamp := ProtoBuf.readString;
            tag_auxiliaryList:
                AddFromBufL(ProtoBuf, FieldNumber, auxiliaryList);
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TCommodity.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_code] then
            ProtoBuf.writeUInt32(tag_code, Fcode);
        if FieldHasValue[tag_name] then
            ProtoBuf.writeString(tag_name, Fname);
        if FieldHasValue[tag_section_code] then
            ProtoBuf.writeString(tag_section_code, Fsection_code);
        if FieldHasValue[tag_quantity] then
            ProtoBuf.writeUInt32(tag_quantity, Fquantity);
        if FieldHasValue[tag_price] then
            SaveMessageFieldToBuf(Fprice, tag_price, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_sum] then
            SaveMessageFieldToBuf(Fsum, tag_sum, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_taxesList] then
            SaveToBufL(ProtoBuf, tag_taxesList, taxesList);
        if FieldHasValue[tag_excise_stamp] then
            ProtoBuf.writeString(tag_excise_stamp, Fexcise_stamp);
        if FieldHasValue[tag_auxiliaryList] then
            SaveToBufL(ProtoBuf, tag_auxiliaryList, auxiliaryList);
    finally
        tmpBuf.Free
    end;
end;


procedure TCommodity.Setcode(Tag: Integer; const Value: Cardinal);
begin
    Fcode := Value;
    FieldHasValue[Tag] := True;
end;


procedure TCommodity.Setname(Tag: Integer; const Value: string);
begin
    Fname := Value;
    FieldHasValue[Tag] := True;
end;


procedure TCommodity.Setsection_code(Tag: Integer; const Value: string);
begin
    Fsection_code := Value;
    FieldHasValue[Tag] := True;
end;


procedure TCommodity.Setquantity(Tag: Integer; const Value: Cardinal);
begin
    Fquantity := Value;
    FieldHasValue[Tag] := True;
end;


procedure TCommodity.Setexcise_stamp(Tag: Integer; const Value: string);
begin
    Fexcise_stamp := Value;
    FieldHasValue[Tag] := True;
end;

{ TStornoCommodity }


constructor TStornoCommodity.Create;
begin
    inherited;
    RegisterRequiredField(tag_section_code);
    RegisterRequiredField(tag_quantity);
    Fprice := TMoney.Create;
    RegisterRequiredField(tag_price);
    Fsum := TMoney.Create;
    RegisterRequiredField(tag_sum);
// FtaxesList := TArray<TTax>.Create;
// FauxiliaryList := TArray<TKeyValuePair>.Create;
end;


destructor TStornoCommodity.Destroy;
begin
    Fprice.Free;
    Fsum.Free;
// FtaxesList.Free;
// FauxiliaryList.Free;
    inherited;
end;


function TStornoCommodity.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_name:
                name := ProtoBuf.readString;
            tag_section_code:
                section_code := ProtoBuf.readString;
            tag_quantity:
                quantity := ProtoBuf.readUInt32;
            tag_price:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fprice.LoadFromBuf(tmpBuf);
                end;
            tag_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fsum.LoadFromBuf(tmpBuf);
                end;
            tag_taxesList:
                AddFromBufL(ProtoBuf, FieldNumber, taxesList);
            tag_excise_stamp:
                excise_stamp := ProtoBuf.readString;
            tag_auxiliaryList:
                AddFromBufL(ProtoBuf, FieldNumber, auxiliaryList);
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TStornoCommodity.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_name] then
            ProtoBuf.writeString(tag_name, Fname);
        if FieldHasValue[tag_section_code] then
            ProtoBuf.writeString(tag_section_code, Fsection_code);
        if FieldHasValue[tag_quantity] then
            ProtoBuf.writeUInt32(tag_quantity, Fquantity);
        if FieldHasValue[tag_price] then
            SaveMessageFieldToBuf(Fprice, tag_price, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_sum] then
            SaveMessageFieldToBuf(Fsum, tag_sum, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_taxesList] then
            SaveToBufL(ProtoBuf, tag_taxesList, taxesList);
        if FieldHasValue[tag_excise_stamp] then
            ProtoBuf.writeString(tag_excise_stamp, Fexcise_stamp);
        if FieldHasValue[tag_auxiliaryList] then
            SaveToBufL(ProtoBuf, tag_auxiliaryList, auxiliaryList);
    finally
        tmpBuf.Free
    end;
end;


procedure TStornoCommodity.Setname(Tag: Integer; const Value: string);
begin
    Fname := Value;
    FieldHasValue[Tag] := True;
end;


procedure TStornoCommodity.Setsection_code(Tag: Integer; const Value: string);
begin
    Fsection_code := Value;
    FieldHasValue[Tag] := True;
end;


procedure TStornoCommodity.Setquantity(Tag: Integer; const Value: Cardinal);
begin
    Fquantity := Value;
    FieldHasValue[Tag] := True;
end;


procedure TStornoCommodity.Setexcise_stamp(Tag: Integer; const Value: string);
begin
    Fexcise_stamp := Value;
    FieldHasValue[Tag] := True;
end;

{ TItem }


constructor TItem.Create;
begin
    inherited;
    RegisterRequiredField(tag_type);
    Fcommodity := TCommodity.Create;
    Fstorno_commodity := TStornoCommodity.Create;
    Fmarkup := TModifier.Create;
    Fstorno_markup := TModifier.Create;
    Fdiscount := TModifier.Create;
    Fstorno_discount := TModifier.Create;
end;


destructor TItem.Destroy;
begin
    Fcommodity.Free;
    Fstorno_commodity.Free;
    Fmarkup.Free;
    Fstorno_markup.Free;
    Fdiscount.Free;
    Fstorno_discount.Free;
    inherited;
end;


function TItem.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_type:
                &type := TItemTypeEnum(ProtoBuf.readEnum);
            tag_commodity:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fcommodity.LoadFromBuf(tmpBuf);
                end;
            tag_storno_commodity:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fstorno_commodity.LoadFromBuf(tmpBuf);
                end;
            tag_markup:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fmarkup.LoadFromBuf(tmpBuf);
                end;
            tag_storno_markup:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fstorno_markup.LoadFromBuf(tmpBuf);
                end;
            tag_discount:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fdiscount.LoadFromBuf(tmpBuf);
                end;
            tag_storno_discount:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fstorno_discount.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TItem.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_type] then
            ProtoBuf.writeInt32(tag_type, Integer(Ftype));
        if FieldHasValue[tag_commodity] then
            SaveMessageFieldToBuf(Fcommodity, tag_commodity, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_storno_commodity] then
            SaveMessageFieldToBuf(Fstorno_commodity, tag_storno_commodity, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_markup] then
            SaveMessageFieldToBuf(Fmarkup, tag_markup, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_storno_markup] then
            SaveMessageFieldToBuf(Fstorno_markup, tag_storno_markup, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_discount] then
            SaveMessageFieldToBuf(Fdiscount, tag_discount, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_storno_discount] then
            SaveMessageFieldToBuf(Fstorno_discount, tag_storno_discount, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;


procedure TItem.Settype(Tag: Integer; const Value: TItemTypeEnum);
begin
    Ftype := Value;
    FieldHasValue[Tag] := True;
end;

{ TServices }


constructor TServices.Create;
begin
    inherited;
    RegisterRequiredField(tag_account_number);
end;


destructor TServices.Destroy;
begin
    inherited;
end;


function TServices.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    case FieldNumber of
        tag_account_number:
            account_number := ProtoBuf.readString;
        else
            Result := False;
    end;
end;


procedure TServices.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
    inherited;
    if FieldHasValue[tag_account_number] then
        ProtoBuf.writeString(tag_account_number, Faccount_number);
end;


procedure TServices.Setaccount_number(Tag: Integer; const Value: string);
begin
    Faccount_number := Value;
    FieldHasValue[Tag] := True;
end;

{ TGasOil }


constructor TGasOil.Create;
begin
    inherited;
    Fcorrection_sum := TMoney.Create;
end;


destructor TGasOil.Destroy;
begin
    Fcorrection_sum.Free;
    inherited;
end;


function TGasOil.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_correction_number:
                correction_number := ProtoBuf.readString;
            tag_correction_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fcorrection_sum.LoadFromBuf(tmpBuf);
                end;
            tag_card_number:
                card_number := ProtoBuf.readString;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TGasOil.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_correction_number] then
            ProtoBuf.writeString(tag_correction_number, Fcorrection_number);
        if FieldHasValue[tag_correction_sum] then
            SaveMessageFieldToBuf(Fcorrection_sum, tag_correction_sum, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_card_number] then
            ProtoBuf.writeString(tag_card_number, Fcard_number);
    finally
        tmpBuf.Free
    end;
end;


procedure TGasOil.Setcorrection_number(Tag: Integer; const Value: string);
begin
    Fcorrection_number := Value;
    FieldHasValue[Tag] := True;
end;


procedure TGasOil.Setcard_number(Tag: Integer; const Value: string);
begin
    Fcard_number := Value;
    FieldHasValue[Tag] := True;
end;

{ TTaxi }


constructor TTaxi.Create;
begin
    inherited;
    RegisterRequiredField(tag_car_number);
    RegisterRequiredField(tag_is_order);
    Fcurrent_fee := TMoney.Create;
    RegisterRequiredField(tag_current_fee);
end;


destructor TTaxi.Destroy;
begin
    Fcurrent_fee.Free;
    inherited;
end;


function TTaxi.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_car_number:
                car_number := ProtoBuf.readString;
            tag_is_order:
                is_order := ProtoBuf.readBoolean;
            tag_current_fee:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fcurrent_fee.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TTaxi.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_car_number] then
            ProtoBuf.writeString(tag_car_number, Fcar_number);
        if FieldHasValue[tag_is_order] then
            ProtoBuf.writeBoolean(tag_is_order, Fis_order);
        if FieldHasValue[tag_current_fee] then
            SaveMessageFieldToBuf(Fcurrent_fee, tag_current_fee, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;


procedure TTaxi.Setcar_number(Tag: Integer; const Value: string);
begin
    Fcar_number := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTaxi.Setis_order(Tag: Integer; const Value: Boolean);
begin
    Fis_order := Value;
    FieldHasValue[Tag] := True;
end;

{ TParking }


constructor TParking.Create;
begin
    inherited;
    Fbegin_time := TDateTime.Create;
    RegisterRequiredField(tag_begin_time);
    Fend_time := TDateTime.Create;
    RegisterRequiredField(tag_end_time);
end;


destructor TParking.Destroy;
begin
    Fbegin_time.Free;
    Fend_time.Free;
    inherited;
end;


function TParking.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_begin_time:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fbegin_time.LoadFromBuf(tmpBuf);
                end;
            tag_end_time:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fend_time.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TParking.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_begin_time] then
            SaveMessageFieldToBuf(Fbegin_time, tag_begin_time, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_end_time] then
            SaveMessageFieldToBuf(Fend_time, tag_end_time, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;

{ TDomain }


constructor TDomain.Create;
begin
    inherited;
    RegisterRequiredField(tag_type);
    Fservices := TServices.Create;
    Fgasoil := TGasOil.Create;
    Ftaxi := TTaxi.Create;
    Fparking := TParking.Create;
end;


destructor TDomain.Destroy;
begin
    Fservices.Free;
    Fgasoil.Free;
    Ftaxi.Free;
    Fparking.Free;
    inherited;
end;


function TDomain.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_type:
                &type := TDomainTypeEnum(ProtoBuf.readEnum);
            tag_services:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fservices.LoadFromBuf(tmpBuf);
                end;
            tag_gasoil:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fgasoil.LoadFromBuf(tmpBuf);
                end;
            tag_taxi:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Ftaxi.LoadFromBuf(tmpBuf);
                end;
            tag_parking:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fparking.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TDomain.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_type] then
            ProtoBuf.writeInt32(tag_type, Integer(Ftype));
        if FieldHasValue[tag_services] then
            SaveMessageFieldToBuf(Fservices, tag_services, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_gasoil] then
            SaveMessageFieldToBuf(Fgasoil, tag_gasoil, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_taxi] then
            SaveMessageFieldToBuf(Ftaxi, tag_taxi, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_parking] then
            SaveMessageFieldToBuf(Fparking, tag_parking, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;


procedure TDomain.Settype(Tag: Integer; const Value: TDomainTypeEnum);
begin
    Ftype := Value;
    FieldHasValue[Tag] := True;
end;

{ TExtensionOptions }


constructor TExtensionOptions.Create;
begin
    inherited;
// FauxiliaryList := TArray<TKeyValuePair>.Create;
end;


destructor TExtensionOptions.Destroy;
begin
// FauxiliaryList.Free;
    inherited;
end;


function TExtensionOptions.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    case FieldNumber of
        tag_customer_email:
            customer_email := ProtoBuf.readString;
        tag_customer_phone:
            customer_phone := ProtoBuf.readString;
        tag_auxiliaryList:
            AddFromBufL(ProtoBuf, FieldNumber, auxiliaryList);
        else
            Result := False;
    end;
end;


procedure TExtensionOptions.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
    inherited;
    if FieldHasValue[tag_customer_email] then
        ProtoBuf.writeString(tag_customer_email, Fcustomer_email);
    if FieldHasValue[tag_customer_phone] then
        ProtoBuf.writeString(tag_customer_phone, Fcustomer_phone);
    if FieldHasValue[tag_auxiliaryList] then
        SaveToBufL(ProtoBuf, tag_auxiliaryList, auxiliaryList);
end;


procedure TExtensionOptions.Setcustomer_email(Tag: Integer; const Value: string);
begin
    Fcustomer_email := Value;
    FieldHasValue[Tag] := True;
end;


procedure TExtensionOptions.Setcustomer_phone(Tag: Integer; const Value: string);
begin
    Fcustomer_phone := Value;
    FieldHasValue[Tag] := True;
end;

{ TPayment }


constructor TPayment.Create;
begin
    inherited;
    RegisterRequiredField(tag_type);
    Fsum := TMoney.Create;
    RegisterRequiredField(tag_sum);
end;


destructor TPayment.Destroy;
begin
    Fsum.Free;
    inherited;
end;


function TPayment.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_type:
                &type := TPaymentTypeEnum(ProtoBuf.readEnum);
            tag_sum:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fsum.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TPayment.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_type] then
            ProtoBuf.writeInt32(tag_type, Integer(Ftype));
        if FieldHasValue[tag_sum] then
            SaveMessageFieldToBuf(Fsum, tag_sum, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;


procedure TPayment.Settype(Tag: Integer; const Value: TPaymentTypeEnum);
begin
    Ftype := Value;
    FieldHasValue[Tag] := True;
end;

{ TAmounts }


constructor TAmounts.Create;
begin
    inherited;
    Ftotal := TMoney.Create;
    RegisterRequiredField(tag_total);
    Ftaken := TMoney.Create;
    Fchange := TMoney.Create;
    Fmarkup := TModifier.Create;
    Fdiscount := TModifier.Create;
end;


destructor TAmounts.Destroy;
begin
    Ftotal.Free;
    Ftaken.Free;
    Fchange.Free;
    Fmarkup.Free;
    Fdiscount.Free;
    inherited;
end;


function TAmounts.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_total:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Ftotal.LoadFromBuf(tmpBuf);
                end;
            tag_taken:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Ftaken.LoadFromBuf(tmpBuf);
                end;
            tag_change:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fchange.LoadFromBuf(tmpBuf);
                end;
            tag_markup:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fmarkup.LoadFromBuf(tmpBuf);
                end;
            tag_discount:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fdiscount.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TAmounts.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_total] then
            SaveMessageFieldToBuf(Ftotal, tag_total, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_taken] then
            SaveMessageFieldToBuf(Ftaken, tag_taken, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_change] then
            SaveMessageFieldToBuf(Fchange, tag_change, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_markup] then
            SaveMessageFieldToBuf(Fmarkup, tag_markup, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_discount] then
            SaveMessageFieldToBuf(Fdiscount, tag_discount, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;

{ TTicketRequest }


constructor TTicketRequest.Create;
begin
    inherited;
    RegisterRequiredField(tag_operation);
    Fdate_time := TDateTime.Create;
    RegisterRequiredField(tag_date_time);
    Foperator := TOperator.Create;
    RegisterRequiredField(tag_operator);
    Fdomain := TDomain.Create;
    RegisterRequiredField(tag_domain);
// FitemsList := TArray<TItem>.Create;
// FpaymentsList := TArray<TPayment>.Create;
// FtaxesList := TArray<TTax>.Create;
// Famounts := TAmounts.Create;
    RegisterRequiredField(tag_amounts);
    Fextension_options := TExtensionOptions.Create;
// Fad_infosList := TArray<TTicketAdInfo>.Create;
end;


destructor TTicketRequest.Destroy;
begin
    Fdate_time.Free;
    Foperator.Free;
    Fdomain.Free;
// FitemsList.Free;
// FpaymentsList.Free;
// FtaxesList.Free;
    Famounts.Free;
    Fextension_options.Free;
// Fad_infosList.Free;
    inherited;
end;


function TTicketRequest.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_operation:
                operation := TOperationTypeEnum(ProtoBuf.readEnum);
            tag_date_time:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fdate_time.LoadFromBuf(tmpBuf);
                end;
            tag_operator:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Foperator.LoadFromBuf(tmpBuf);
                end;
            tag_domain:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fdomain.LoadFromBuf(tmpBuf);
                end;
            tag_itemsList:
                AddFromBufL(ProtoBuf, FieldNumber, itemsList);
            tag_paymentsList:
                AddFromBufL(ProtoBuf, FieldNumber, paymentsList);
            tag_taxesList:
                AddFromBufL(ProtoBuf, FieldNumber, taxesList);
            tag_amounts:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Famounts.LoadFromBuf(tmpBuf);
                end;
            tag_extension_options:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fextension_options.LoadFromBuf(tmpBuf);
                end;
            tag_offline_ticket_number:
                offline_ticket_number := ProtoBuf.readUInt32;
            tag_printed_document_number:
                printed_document_number := ProtoBuf.readString;
            tag_printed_ticket:
                printed_ticket := ProtoBuf.readString;
            tag_ad_infosList:
                AddFromBufL(ProtoBuf, FieldNumber, ad_infosList);
            tag_fr_shift_number:
                fr_shift_number := ProtoBuf.readUInt32;
            tag_shift_document_number:
                shift_document_number := ProtoBuf.readUInt32;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TTicketRequest.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_operation] then
            ProtoBuf.writeInt32(tag_operation, Integer(Foperation));
        if FieldHasValue[tag_date_time] then
            SaveMessageFieldToBuf(Fdate_time, tag_date_time, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_operator] then
            SaveMessageFieldToBuf(Foperator, tag_operator, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_domain] then
            SaveMessageFieldToBuf(Fdomain, tag_domain, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_itemsList] then
            SaveToBufL(ProtoBuf, tag_itemsList, itemsList);
        if FieldHasValue[tag_paymentsList] then
            SaveToBufL(ProtoBuf, tag_paymentsList, paymentsList);
        if FieldHasValue[tag_taxesList] then
            SaveToBufL(ProtoBuf, tag_taxesList, taxesList);
        if FieldHasValue[tag_amounts] then
            SaveMessageFieldToBuf(Famounts, tag_amounts, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_extension_options] then
            SaveMessageFieldToBuf(Fextension_options, tag_extension_options, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_offline_ticket_number] then
            ProtoBuf.writeUInt32(tag_offline_ticket_number, Foffline_ticket_number);
        if FieldHasValue[tag_printed_document_number] then
            ProtoBuf.writeString(tag_printed_document_number, Fprinted_document_number);
        if FieldHasValue[tag_printed_ticket] then
            ProtoBuf.writeString(tag_printed_ticket, Fprinted_ticket);
        if FieldHasValue[tag_ad_infosList] then
            SaveToBufL(ProtoBuf, tag_ad_infosList, ad_infosList);
        if FieldHasValue[tag_fr_shift_number] then
            ProtoBuf.writeUInt32(tag_fr_shift_number, Ffr_shift_number);
        if FieldHasValue[tag_shift_document_number] then
            ProtoBuf.writeUInt32(tag_shift_document_number, Fshift_document_number);
    finally
        tmpBuf.Free
    end;
end;


procedure TTicketRequest.Setoperation(Tag: Integer; const Value: TOperationTypeEnum);
begin
    Foperation := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTicketRequest.Setoffline_ticket_number(Tag: Integer; const Value: Cardinal);
begin
    Foffline_ticket_number := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTicketRequest.Setprinted_document_number(Tag: Integer; const Value: string);
begin
    Fprinted_document_number := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTicketRequest.Setprinted_ticket(Tag: Integer; const Value: string);
begin
    Fprinted_ticket := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTicketRequest.Setfr_shift_number(Tag: Integer; const Value: Cardinal);
begin
    Ffr_shift_number := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTicketRequest.Setshift_document_number(Tag: Integer; const Value: Cardinal);
begin
    Fshift_document_number := Value;
    FieldHasValue[Tag] := True;
end;

{ TTicketResponse }


constructor TTicketResponse.Create;
begin
    inherited;
    RegisterRequiredField(tag_ticket_number);
end;


destructor TTicketResponse.Destroy;
begin
    inherited;
end;


function TTicketResponse.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    case FieldNumber of
        tag_ticket_number:
            ticket_number := ProtoBuf.readString;
        tag_qr_code:
            qr_code := ProtoBuf.readBytes;
        else
            Result := False;
    end;
end;


procedure TTicketResponse.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
    inherited;
    if FieldHasValue[tag_ticket_number] then
        ProtoBuf.writeString(tag_ticket_number, Fticket_number);
    if FieldHasValue[tag_qr_code] then
        ProtoBuf.writeBytes(tag_qr_code, Fqr_code);
end;


procedure TTicketResponse.Setticket_number(Tag: Integer; const Value: string);
begin
    Fticket_number := Value;
    FieldHasValue[Tag] := True;
end;


procedure TTicketResponse.Setqr_code(Tag: Integer; const Value: TBytes);
begin
    Fqr_code := Value;
    FieldHasValue[Tag] := True;
end;

end.
