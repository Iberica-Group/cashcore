unit proto.service; { 125 }

interface

// ***********************************
// classes for proto.service.proto
// generated by ProtoBufGenerator
// kami-soft 2016-2017
// ***********************************

uses
    SysUtils,
    Classes,
    pbInput,
    pbOutput,
    pbPublic,
    uAbstractProtoBufClasses,
    proto.common,
    proto.reginfo,
    proto.bind_taxation;

type
    TCommQuality = class(TAbstractProtoBufClass)
    public const
        tag_avg_connect_time = 1;

    const
        tag_avg_ping = 2;

    const
        tag_loss_ratio = 3;
    strict private
        Favg_connect_time: Cardinal;
        Favg_ping: Cardinal;
        Floss_ratio: Cardinal;

        procedure Setavg_connect_time(Tag: Integer; const Value: Cardinal);
        procedure Setavg_ping(Tag: Integer; const Value: Cardinal);
        procedure Setloss_ratio(Tag: Integer; const Value: Cardinal);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property avg_connect_time: Cardinal index tag_avg_connect_time read Favg_connect_time write Setavg_connect_time;
        property avg_ping: Cardinal index tag_avg_ping read Favg_ping write Setavg_ping;
        property loss_ratio: Cardinal index tag_loss_ratio read Floss_ratio write Setloss_ratio;
    end;


    TGeoPosition = class(TAbstractProtoBufClass)
    public const
        tag_latitude = 1;

    const
        tag_longitude = 2;
    strict private
        Flatitude: Integer;
        Flongitude: Integer;

        procedure Setlatitude(Tag: Integer; const Value: Integer);
        procedure Setlongitude(Tag: Integer; const Value: Integer);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property latitude: Integer index tag_latitude read Flatitude write Setlatitude;
        property longitude: Integer index tag_longitude read Flongitude write Setlongitude;
    end;


    TSecurityStats = class(TAbstractProtoBufClass)
    public const
        tag_geo_position = 1;

    const
        tag_os_version = 2;
    strict private
        Fgeo_position: TGeoPosition;
        Fos_version: string;

        procedure Setos_version(Tag: Integer; const Value: string);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property geo_position: TGeoPosition read Fgeo_position;
        property os_version: string index tag_os_version read Fos_version write Setos_version;
    end;


    TOfflinePeriod = class(TAbstractProtoBufClass)
    public const
        tag_begin_time = 1;

    const
        tag_end_time = 2;
    strict private
        Fbegin_time: TDateTime;
        Fend_time: TDateTime;

    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property begin_time: TDateTime read Fbegin_time;
        property end_time: TDateTime read Fend_time;
    end;


    TRegInfo = class(TAbstractProtoBufClass)
    public const
        tag_kkm = 1;

    const
        tag_pos = 2;

    const
        tag_org = 3;

    strict private
        Fkkm: TKkmRegInfo;
        Fpos: TPosRegInfo;
        Forg: TOrgRegInfo;

    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property kkm: TKkmRegInfo read Fkkm;
        property pos: TPosRegInfo read Fpos;
        property org: TOrgRegInfo read Forg;
    end;


    TServiceRequestRegInfo = class(TAbstractProtoBufClass)
    public
         const
        tag_kkm = 1;

    const
        tag_org = 2;

    strict private
        Fkkm: TKkmRegInfo;
        Forg: TOrgRegInfo;

    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property kkm: TKkmRegInfo read Fkkm;
        property org: TOrgRegInfo read Forg;
    end;


    TDeviceInformation = class(TAbstractProtoBufClass)
    public const
        tag_manufacturer = 1;

    const
        tag_model = 2;

    const
        tag_firmware_version = 3;
    strict private
        Fmanufacturer: string;
        Fmodel: string;
        Ffirmware_version: string;

        procedure Setmanufacturer(Tag: Integer; const Value: string);
        procedure Setmodel(Tag: Integer; const Value: string);
        procedure Setfirmware_version(Tag: Integer; const Value: string);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        property manufacturer: string index tag_manufacturer read Fmanufacturer write Setmanufacturer;
        property model: string index tag_model read Fmodel write Setmodel;
        property firmware_version: string index tag_firmware_version read Ffirmware_version write Setfirmware_version;
    end;


    TModuleInformation = class(TAbstractProtoBufClass)
    public const
        tag_name = 1;

    const
        tag_version = 2;

    const
        tag_build_info = 3;

    const
        tag_device_info = 4;

    const
        tag_extended_infoList = 5;

    const
        tag_build_arch = 6;
    strict private
        Fname: string;
        Fversion: string;
        Fbuild_info: string;
        Fdevice_info: TDeviceInformation;
        Fextended_infoList: TProtoBufClassList<TKeyValuePair>;
        Fbuild_arch: string;

        procedure Setname(Tag: Integer; const Value: string);
        procedure Setversion(Tag: Integer; const Value: string);
        procedure Setbuild_info(Tag: Integer; const Value: string);
        procedure Setbuild_arch(Tag: Integer; const Value: string);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property name: string index tag_name read Fname write Setname;
        property version: string index tag_version read Fversion write Setversion;
        property build_info: string index tag_build_info read Fbuild_info write Setbuild_info;
        property device_info: TDeviceInformation read Fdevice_info;
        property extended_infoList: TProtoBufClassList<TKeyValuePair> read Fextended_infoList;
        property build_arch: string index tag_build_arch read Fbuild_arch write Setbuild_arch;
    end;


    TSoftwareInformation = class(TAbstractProtoBufClass)
    public const
        tag_module_infosList = 1;

    const
        tag_hardware_arch = 2;

    const
        tag_os_family = 3;

    const
        tag_os_version = 4;

    const
        tag_os_extended_info = 5;

    const
        tag_runtime_version = 6;

    const
        tag_partner_id = 7;
    strict private
        Fmodule_infosList: TProtoBufClassList<TModuleInformation>;
        Fhardware_arch: string;
        Fos_family: string;
        Fos_version: string;
        Fos_extended_info: string;
        Fruntime_version: string;
        Fpartner_id: Cardinal;

        procedure Sethardware_arch(Tag: Integer; const Value: string);
        procedure Setos_family(Tag: Integer; const Value: string);
        procedure Setos_version(Tag: Integer; const Value: string);
        procedure Setos_extended_info(Tag: Integer; const Value: string);
        procedure Setruntime_version(Tag: Integer; const Value: string);
        procedure Setpartner_id(Tag: Integer; const Value: Cardinal);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property module_infosList: TProtoBufClassList<TModuleInformation> read Fmodule_infosList;
        property hardware_arch: string index tag_hardware_arch read Fhardware_arch write Sethardware_arch;
        property os_family: string index tag_os_family read Fos_family write Setos_family;
        property os_version: string index tag_os_version read Fos_version write Setos_version;
        property os_extended_info: string index tag_os_extended_info read Fos_extended_info write Setos_extended_info;
        property runtime_version: string index tag_runtime_version read Fruntime_version write Setruntime_version;
        property partner_id: Cardinal index tag_partner_id read Fpartner_id write Setpartner_id;
    end;


    TServiceRequest = class(TAbstractProtoBufClass)
    public const
        tag_comm_quality = 1;

    const
        tag_security_stats = 3;

    const
        tag_offline_period = 4;

    const
        tag_nomenclature_version = 5;

    const
        tag_ticket_ad_infosList = 6;

    const
        tag_get_reg_info = 7;

    const
        tag_get_binded_taxation = 8;

    const
        tag_marker = 9;

    const
        tag_software_information = 11;

    const
        tag_reg_info = 12;

    const
        tag_auxiliaryList = 60;
    strict private
        Fcomm_quality: TCommQuality;
        Fsecurity_stats: TSecurityStats;
        Foffline_period: TOfflinePeriod;
        Fnomenclature_version: Cardinal;
        Fticket_ad_infosList: TProtoBufClassList<TTicketAdInfo>;
        Fget_reg_info: Boolean;
        Fget_binded_taxation: Boolean;
        Fmarker: UInt64;
        Fsoftware_information: TSoftwareInformation;
        Freg_info: TServiceRequestRegInfo;
        FauxiliaryList: TProtoBufClassList<TKeyValuePair>;

        procedure Setnomenclature_version(Tag: Integer; const Value: Cardinal);
        procedure Setget_reg_info(Tag: Integer; const Value: Boolean);
        procedure Setget_binded_taxation(Tag: Integer; const Value: Boolean);
        procedure Setmarker(Tag: Integer; const Value: UInt64);
    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property comm_quality: TCommQuality read Fcomm_quality;
        property security_stats: TSecurityStats read Fsecurity_stats;
        property offline_period: TOfflinePeriod read Foffline_period;
        property nomenclature_version: Cardinal index tag_nomenclature_version read Fnomenclature_version write Setnomenclature_version;
        property ticket_ad_infosList: TProtoBufClassList<TTicketAdInfo> read Fticket_ad_infosList;
        property get_reg_info: Boolean index tag_get_reg_info read Fget_reg_info write Setget_reg_info;
        property get_binded_taxation: Boolean index tag_get_binded_taxation read Fget_binded_taxation write Setget_binded_taxation;
        property marker: UInt64 index tag_marker read Fmarker write Setmarker;
        property software_information: TSoftwareInformation read Fsoftware_information;
        property reg_info: TServiceRequestRegInfo read Freg_info;
        property auxiliaryList: TProtoBufClassList<TKeyValuePair> read FauxiliaryList;
    end;


    TServiceResponse = class(TAbstractProtoBufClass)
    public const
        tag_ticket_adsList = 1;

    const
        tag_reg_info = 2;

    const
        tag_binded_taxation = 3;

    const
        tag_auxiliaryList = 30;
    strict private
        Fticket_adsList: TProtoBufClassList<TTicketAd>;
        Freg_info: TRegInfo;
        Fbinded_taxation: TBindedTaxation;
        FauxiliaryList: TProtoBufClassList<TKeyValuePair>;

    strict protected
        function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
        procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
    public
        constructor Create; override;
        destructor Destroy; override;

        property ticket_adsList: TProtoBufClassList<TTicketAd> read Fticket_adsList;
        property reg_info: TRegInfo read Freg_info;
        property binded_taxation: TBindedTaxation read Fbinded_taxation;
        property auxiliaryList: TProtoBufClassList<TKeyValuePair> read FauxiliaryList;
    end;

implementation

{ TCommQuality }


constructor TCommQuality.Create;
begin
    inherited;
    RegisterRequiredField(tag_avg_connect_time);
end;


destructor TCommQuality.Destroy;
begin
    inherited;
end;


function TCommQuality.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    case FieldNumber of
        tag_avg_connect_time:
            avg_connect_time := ProtoBuf.readUInt32;
        tag_avg_ping:
            avg_ping := ProtoBuf.readUInt32;
        tag_loss_ratio:
            loss_ratio := ProtoBuf.readUInt32;
        else
            Result := False;
    end;
end;


procedure TCommQuality.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
    inherited;
    if FieldHasValue[tag_avg_connect_time] then
        ProtoBuf.writeUInt32(tag_avg_connect_time, Favg_connect_time);
    if FieldHasValue[tag_avg_ping] then
        ProtoBuf.writeUInt32(tag_avg_ping, Favg_ping);
    if FieldHasValue[tag_loss_ratio] then
        ProtoBuf.writeUInt32(tag_loss_ratio, Floss_ratio);
end;


procedure TCommQuality.Setavg_connect_time(Tag: Integer; const Value: Cardinal);
begin
    Favg_connect_time := Value;
    FieldHasValue[Tag] := True;
end;


procedure TCommQuality.Setavg_ping(Tag: Integer; const Value: Cardinal);
begin
    Favg_ping := Value;
    FieldHasValue[Tag] := True;
end;


procedure TCommQuality.Setloss_ratio(Tag: Integer; const Value: Cardinal);
begin
    Floss_ratio := Value;
    FieldHasValue[Tag] := True;
end;

{ TGeoPosition }


constructor TGeoPosition.Create;
begin
    inherited;
    RegisterRequiredField(tag_latitude);
    RegisterRequiredField(tag_longitude);
end;


destructor TGeoPosition.Destroy;
begin
    inherited;
end;


function TGeoPosition.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    case FieldNumber of
        tag_latitude:
            latitude := ProtoBuf.readInt32;
        tag_longitude:
            longitude := ProtoBuf.readInt32;
        else
            Result := False;
    end;
end;


procedure TGeoPosition.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
    inherited;
    if FieldHasValue[tag_latitude] then
        ProtoBuf.writeInt32(tag_latitude, Flatitude);
    if FieldHasValue[tag_longitude] then
        ProtoBuf.writeInt32(tag_longitude, Flongitude);
end;


procedure TGeoPosition.Setlatitude(Tag: Integer; const Value: Integer);
begin
    Flatitude := Value;
    FieldHasValue[Tag] := True;
end;


procedure TGeoPosition.Setlongitude(Tag: Integer; const Value: Integer);
begin
    Flongitude := Value;
    FieldHasValue[Tag] := True;
end;

{ TSecurityStats }


constructor TSecurityStats.Create;
begin
    inherited;
    Fgeo_position := TGeoPosition.Create;
end;


destructor TSecurityStats.Destroy;
begin
    Fgeo_position.Free;
    inherited;
end;


function TSecurityStats.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_geo_position:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fgeo_position.LoadFromBuf(tmpBuf);
                end;
            tag_os_version:
                os_version := ProtoBuf.readString;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TSecurityStats.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_geo_position] then
            SaveMessageFieldToBuf(Fgeo_position, tag_geo_position, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_os_version] then
            ProtoBuf.writeString(tag_os_version, Fos_version);
    finally
        tmpBuf.Free
    end;
end;


procedure TSecurityStats.Setos_version(Tag: Integer; const Value: string);
begin
    Fos_version := Value;
    FieldHasValue[Tag] := True;
end;

{ TOfflinePeriod }


constructor TOfflinePeriod.Create;
begin
    inherited;
    Fbegin_time := TDateTime.Create;
    RegisterRequiredField(tag_begin_time);
    Fend_time := TDateTime.Create;
    RegisterRequiredField(tag_end_time);
end;


destructor TOfflinePeriod.Destroy;
begin
    Fbegin_time.Free;
    Fend_time.Free;
    inherited;
end;


function TOfflinePeriod.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_begin_time:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fbegin_time.LoadFromBuf(tmpBuf);
                end;
            tag_end_time:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fend_time.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TOfflinePeriod.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_begin_time] then
            SaveMessageFieldToBuf(Fbegin_time, tag_begin_time, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_end_time] then
            SaveMessageFieldToBuf(Fend_time, tag_end_time, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;

{ TRegInfo }


constructor TRegInfo.Create;
begin
    inherited;
    Fkkm := TKkmRegInfo.Create;
    Fpos := TPosRegInfo.Create;
    Forg := TOrgRegInfo.Create;
end;


destructor TRegInfo.Destroy;
begin
    Fkkm.Free;
    Fpos.Free;
    Forg.Free;
    inherited;
end;


function TRegInfo.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_kkm:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fkkm.LoadFromBuf(tmpBuf);
                end;
            tag_pos:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fpos.LoadFromBuf(tmpBuf);
                end;
            tag_org:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Forg.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TRegInfo.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_kkm] then
            SaveMessageFieldToBuf(Fkkm, tag_kkm, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_pos] then
            SaveMessageFieldToBuf(Fpos, tag_pos, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_org] then
            SaveMessageFieldToBuf(Forg, tag_org, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;
end;

{ TDeviceInformation }


function TDeviceInformation.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    case FieldNumber of
        tag_manufacturer:
            manufacturer := ProtoBuf.readString;
        tag_model:
            model := ProtoBuf.readString;
        tag_firmware_version:
            firmware_version := ProtoBuf.readString;
        else
            Result := False;
    end;
end;


procedure TDeviceInformation.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
    inherited;
    if FieldHasValue[tag_manufacturer] then
        ProtoBuf.writeString(tag_manufacturer, Fmanufacturer);
    if FieldHasValue[tag_model] then
        ProtoBuf.writeString(tag_model, Fmodel);
    if FieldHasValue[tag_firmware_version] then
        ProtoBuf.writeString(tag_firmware_version, Ffirmware_version);
end;


procedure TDeviceInformation.Setmanufacturer(Tag: Integer; const Value: string);
begin
    Fmanufacturer := Value;
    FieldHasValue[Tag] := True;
end;


procedure TDeviceInformation.Setmodel(Tag: Integer; const Value: string);
begin
    Fmodel := Value;
    FieldHasValue[Tag] := True;
end;


procedure TDeviceInformation.Setfirmware_version(Tag: Integer; const Value: string);
begin
    Ffirmware_version := Value;
    FieldHasValue[Tag] := True;
end;

{ TModuleInformation }


constructor TModuleInformation.Create;
begin
    inherited;
    RegisterRequiredField(tag_name);
    RegisterRequiredField(tag_version);
    Fdevice_info := TDeviceInformation.Create;
    Fextended_infoList := TProtoBufClassList<TKeyValuePair>.Create;
end;


destructor TModuleInformation.Destroy;
begin
    Fdevice_info.Free;
    Fextended_infoList.Free;
    inherited;
end;


function TModuleInformation.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_name:
                name := ProtoBuf.readString;
            tag_version:
                version := ProtoBuf.readString;
            tag_build_info:
                build_info := ProtoBuf.readString;
            tag_device_info:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fdevice_info.LoadFromBuf(tmpBuf);
                end;
            tag_extended_infoList:
                Fextended_infoList.AddFromBuf(ProtoBuf, FieldNumber);
            tag_build_arch:
                build_arch := ProtoBuf.readString;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TModuleInformation.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_name] then
            ProtoBuf.writeString(tag_name, Fname);
        if FieldHasValue[tag_version] then
            ProtoBuf.writeString(tag_version, Fversion);
        if FieldHasValue[tag_build_info] then
            ProtoBuf.writeString(tag_build_info, Fbuild_info);
        if FieldHasValue[tag_device_info] then
            SaveMessageFieldToBuf(Fdevice_info, tag_device_info, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_extended_infoList] then
            Fextended_infoList.SaveToBuf(ProtoBuf, tag_extended_infoList);
        if FieldHasValue[tag_build_arch] then
            ProtoBuf.writeString(tag_build_arch, Fbuild_arch);
    finally
        tmpBuf.Free
    end;
end;


procedure TModuleInformation.Setname(Tag: Integer; const Value: string);
begin
    Fname := Value;
    FieldHasValue[Tag] := True;
end;


procedure TModuleInformation.Setversion(Tag: Integer; const Value: string);
begin
    Fversion := Value;
    FieldHasValue[Tag] := True;
end;


procedure TModuleInformation.Setbuild_info(Tag: Integer; const Value: string);
begin
    Fbuild_info := Value;
    FieldHasValue[Tag] := True;
end;


procedure TModuleInformation.Setbuild_arch(Tag: Integer; const Value: string);
begin
    Fbuild_arch := Value;
    FieldHasValue[Tag] := True;
end;

{ TSoftwareInformation }


constructor TSoftwareInformation.Create;
begin
    inherited;
    Fmodule_infosList := TProtoBufClassList<TModuleInformation>.Create;
end;


destructor TSoftwareInformation.Destroy;
begin
    Fmodule_infosList.Free;
    inherited;
end;


function TSoftwareInformation.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    case FieldNumber of
        tag_module_infosList:
            Fmodule_infosList.AddFromBuf(ProtoBuf, FieldNumber);
        tag_hardware_arch:
            hardware_arch := ProtoBuf.readString;
        tag_os_family:
            os_family := ProtoBuf.readString;
        tag_os_version:
            os_version := ProtoBuf.readString;
        tag_os_extended_info:
            os_extended_info := ProtoBuf.readString;
        tag_runtime_version:
            runtime_version := ProtoBuf.readString;
        tag_partner_id:
            partner_id := ProtoBuf.readUInt32;
        else
            Result := False;
    end;
end;


procedure TSoftwareInformation.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
    inherited;
    if FieldHasValue[tag_module_infosList] then
        Fmodule_infosList.SaveToBuf(ProtoBuf, tag_module_infosList);
    if FieldHasValue[tag_hardware_arch] then
        ProtoBuf.writeString(tag_hardware_arch, Fhardware_arch);
    if FieldHasValue[tag_os_family] then
        ProtoBuf.writeString(tag_os_family, Fos_family);
    if FieldHasValue[tag_os_version] then
        ProtoBuf.writeString(tag_os_version, Fos_version);
    if FieldHasValue[tag_os_extended_info] then
        ProtoBuf.writeString(tag_os_extended_info, Fos_extended_info);
    if FieldHasValue[tag_runtime_version] then
        ProtoBuf.writeString(tag_runtime_version, Fruntime_version);
    if FieldHasValue[tag_partner_id] then
        ProtoBuf.writeUInt32(tag_partner_id, Fpartner_id);
end;


procedure TSoftwareInformation.Sethardware_arch(Tag: Integer; const Value: string);
begin
    Fhardware_arch := Value;
    FieldHasValue[Tag] := True;
end;


procedure TSoftwareInformation.Setos_family(Tag: Integer; const Value: string);
begin
    Fos_family := Value;
    FieldHasValue[Tag] := True;
end;


procedure TSoftwareInformation.Setos_version(Tag: Integer; const Value: string);
begin
    Fos_version := Value;
    FieldHasValue[Tag] := True;
end;


procedure TSoftwareInformation.Setos_extended_info(Tag: Integer; const Value: string);
begin
    Fos_extended_info := Value;
    FieldHasValue[Tag] := True;
end;


procedure TSoftwareInformation.Setruntime_version(Tag: Integer; const Value: string);
begin
    Fruntime_version := Value;
    FieldHasValue[Tag] := True;
end;


procedure TSoftwareInformation.Setpartner_id(Tag: Integer; const Value: Cardinal);
begin
    Fpartner_id := Value;
    FieldHasValue[Tag] := True;
end;

{ TServiceRequest }


constructor TServiceRequest.Create;
begin
    inherited;
    Fcomm_quality := TCommQuality.Create;
    Fsecurity_stats := TSecurityStats.Create;
    Foffline_period := TOfflinePeriod.Create;
    Fticket_ad_infosList := TProtoBufClassList<TTicketAdInfo>.Create;
    Fsoftware_information := TSoftwareInformation.Create;
    Freg_info := TServiceRequestRegInfo.Create;
    FauxiliaryList := TProtoBufClassList<TKeyValuePair>.Create;
end;


destructor TServiceRequest.Destroy;
begin
    Fcomm_quality.Free;
    Fsecurity_stats.Free;
    Foffline_period.Free;
    Fticket_ad_infosList.Free;
    Fsoftware_information.Free;
    Freg_info.Free;
    FauxiliaryList.Free;
    inherited;
end;


function TServiceRequest.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_comm_quality:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fcomm_quality.LoadFromBuf(tmpBuf);
                end;
            tag_security_stats:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fsecurity_stats.LoadFromBuf(tmpBuf);
                end;
            tag_offline_period:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Foffline_period.LoadFromBuf(tmpBuf);
                end;
            tag_nomenclature_version:
                nomenclature_version := ProtoBuf.readUInt32;
            tag_ticket_ad_infosList:
                Fticket_ad_infosList.AddFromBuf(ProtoBuf, FieldNumber);
            tag_get_reg_info:
                get_reg_info := ProtoBuf.readBoolean;
            tag_get_binded_taxation:
                get_binded_taxation := ProtoBuf.readBoolean;
            tag_marker:
                marker := ProtoBuf.readInt64;
            tag_software_information:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fsoftware_information.LoadFromBuf(tmpBuf);
                end;
            tag_reg_info:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Freg_info.LoadFromBuf(tmpBuf);
                end;
            tag_auxiliaryList:
                FauxiliaryList.AddFromBuf(ProtoBuf, FieldNumber);
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TServiceRequest.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_comm_quality] then
            SaveMessageFieldToBuf(Fcomm_quality, tag_comm_quality, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_security_stats] then
            SaveMessageFieldToBuf(Fsecurity_stats, tag_security_stats, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_offline_period] then
            SaveMessageFieldToBuf(Foffline_period, tag_offline_period, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_nomenclature_version] then
            ProtoBuf.writeUInt32(tag_nomenclature_version, Fnomenclature_version);
        if FieldHasValue[tag_ticket_ad_infosList] then
            Fticket_ad_infosList.SaveToBuf(ProtoBuf, tag_ticket_ad_infosList);
        if FieldHasValue[tag_get_reg_info] then
            ProtoBuf.writeBoolean(tag_get_reg_info, Fget_reg_info);
        if FieldHasValue[tag_get_binded_taxation] then
            ProtoBuf.writeBoolean(tag_get_binded_taxation, Fget_binded_taxation);
        if FieldHasValue[tag_marker] then
            ProtoBuf.writeInt64(tag_marker, Fmarker);
        if FieldHasValue[tag_software_information] then
            SaveMessageFieldToBuf(Fsoftware_information, tag_software_information, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_reg_info] then
            SaveMessageFieldToBuf(Freg_info, tag_reg_info, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_auxiliaryList] then
            FauxiliaryList.SaveToBuf(ProtoBuf, tag_auxiliaryList);
    finally
        tmpBuf.Free
    end;
end;


procedure TServiceRequest.Setnomenclature_version(Tag: Integer; const Value: Cardinal);
begin
    Fnomenclature_version := Value;
    FieldHasValue[Tag] := True;
end;


procedure TServiceRequest.Setget_reg_info(Tag: Integer; const Value: Boolean);
begin
    Fget_reg_info := Value;
    FieldHasValue[Tag] := True;
end;


procedure TServiceRequest.Setget_binded_taxation(Tag: Integer; const Value: Boolean);
begin
    Fget_binded_taxation := Value;
    FieldHasValue[Tag] := True;
end;


procedure TServiceRequest.Setmarker(Tag: Integer; const Value: UInt64);
begin
    Fmarker := Value;
    FieldHasValue[Tag] := True;
end;

{ TServiceResponse }


constructor TServiceResponse.Create;
begin
    inherited;
    Fticket_adsList := TProtoBufClassList<TTicketAd>.Create;
    Freg_info := TRegInfo.Create;
    Fbinded_taxation := TBindedTaxation.Create;
    FauxiliaryList := TProtoBufClassList<TKeyValuePair>.Create;
end;


destructor TServiceResponse.Destroy;
begin
    Fticket_adsList.Free;
    Freg_info.Free;
    Fbinded_taxation.Free;
    FauxiliaryList.Free;
    inherited;
end;


function TServiceResponse.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_ticket_adsList:
                Fticket_adsList.AddFromBuf(ProtoBuf, FieldNumber);
            tag_reg_info:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Freg_info.LoadFromBuf(tmpBuf);
                end;
            tag_binded_taxation:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fbinded_taxation.LoadFromBuf(tmpBuf);
                end;
            tag_auxiliaryList:
                FauxiliaryList.AddFromBuf(ProtoBuf, FieldNumber);
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TServiceResponse.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_ticket_adsList] then
            Fticket_adsList.SaveToBuf(ProtoBuf, tag_ticket_adsList);
        if FieldHasValue[tag_reg_info] then
            SaveMessageFieldToBuf(Freg_info, tag_reg_info, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_binded_taxation] then
            SaveMessageFieldToBuf(Fbinded_taxation, tag_binded_taxation, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_auxiliaryList] then
            FauxiliaryList.SaveToBuf(ProtoBuf, tag_auxiliaryList);
    finally
        tmpBuf.Free
    end;
end;

{ TServiceRequestRegInfo }


constructor TServiceRequestRegInfo.Create;
begin
    inherited;
    Fkkm := TKkmRegInfo.Create;
    Forg := TOrgRegInfo.Create;
end;


destructor TServiceRequestRegInfo.Destroy;
begin
    Fkkm.Free;
    Forg.Free;
    inherited;
end;


function TServiceRequestRegInfo.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber, WireType: Integer): Boolean;
var
    tmpBuf: TProtoBufInput;
begin
    Result := inherited;
    if Result then
        Exit;
    Result := True;
    tmpBuf := nil;
    try
        case FieldNumber of
            tag_kkm:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Fkkm.LoadFromBuf(tmpBuf);
                end;
            tag_org:
                begin
                    tmpBuf := ProtoBuf.ReadSubProtoBufInput;
                    Forg.LoadFromBuf(tmpBuf);
                end;
            else
                Result := False;
        end;
    finally
        tmpBuf.Free
    end;
end;


procedure TServiceRequestRegInfo.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
    tmpBuf: TProtoBufOutput;
begin
    inherited;
    tmpBuf := TProtoBufOutput.Create;
    try
        if FieldHasValue[tag_kkm] then
            SaveMessageFieldToBuf(Fkkm, tag_kkm, tmpBuf, ProtoBuf);
        if FieldHasValue[tag_org] then
            SaveMessageFieldToBuf(Forg, tag_org, tmpBuf, ProtoBuf);
    finally
        tmpBuf.Free
    end;

end;

end.
