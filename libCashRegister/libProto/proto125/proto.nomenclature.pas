unit proto.nomenclature; {125}

interface

// *********************************** 
//   classes for proto.nomenclature.proto
//   generated by ProtoBufGenerator 
//        kami-soft 2016-2017
// ***********************************

uses
  SysUtils,
  Classes,
  pbInput,
  pbOutput,
  pbPublic,
  uAbstractProtoBufClasses,
  proto.common;

type
  TElementTypeEnum=(
    GROUP = 0,
    ITEM = 1
  );

  TNomenclatureResultTypeEnum=(
    RESULT_TYPE_OK = 0,
    RESULT_TYPE_VERSION_IS_ACTUAL = 1,
    RESULT_TYPE_NO_VERSION = 2
  );

  TNomenclatureRequest = class(TAbstractProtoBufClass)
  public
    const tag_current_version = 1;
  strict private
    Fcurrent_version: Cardinal;

    procedure Setcurrent_version(Tag: Integer; const Value: Cardinal);
  strict protected
    function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
    procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
  public
    constructor Create; override;
    destructor Destroy; override;

    property current_version: Cardinal index tag_current_version read Fcurrent_version write Setcurrent_version;
  end;

  TTax = class(TAbstractProtoBufClass)
  public
    const tag_taxation_type = 1;
    const tag_tax_type = 2;
    const tag_tax_percent = 3;
  strict private
    Ftaxation_type: Cardinal;
    Ftax_type: Cardinal;
    Ftax_percent: Cardinal;

    procedure Settaxation_type(Tag: Integer; const Value: Cardinal);
    procedure Settax_type(Tag: Integer; const Value: Cardinal);
    procedure Settax_percent(Tag: Integer; const Value: Cardinal);
  strict protected
    function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
    procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
  public
    constructor Create; override;
    destructor Destroy; override;

    property taxation_type: Cardinal index tag_taxation_type read Ftaxation_type write Settaxation_type;
    property tax_type: Cardinal index tag_tax_type read Ftax_type write Settax_type;
    property tax_percent: Cardinal index tag_tax_percent read Ftax_percent write Settax_percent;
  end;

  TItem = class(TAbstractProtoBufClass)
  public
    const tag_article = 1;
    const tag_barcode = 2;
    const tag_description = 3;
    const tag_purchase_price = 6;
    const tag_sell_price = 7;
    const tag_discount_percent = 8;
    const tag_discount_sum = 9;
    const tag_markup_percent = 10;
    const tag_markup_sum = 11;
    const tag_taxesList = 12;
    const tag_measure_count = 13;
    const tag_measure_title = 14;
    const tag_measure_fractional = 15;
  strict private
    Farticle: string;
    Fbarcode: string;
    Fdescription: string;
    Fpurchase_price: TMoney;
    Fsell_price: TMoney;
    Fdiscount_percent: Cardinal;
    Fdiscount_sum: TMoney;
    Fmarkup_percent: Cardinal;
    Fmarkup_sum: TMoney;
    FtaxesList: TProtoBufClassList<TTax>;
    Fmeasure_count: Cardinal;
    Fmeasure_title: string;
    Fmeasure_fractional: Boolean;

    procedure Setarticle(Tag: Integer; const Value: string);
    procedure Setbarcode(Tag: Integer; const Value: string);
    procedure Setdescription(Tag: Integer; const Value: string);
    procedure Setdiscount_percent(Tag: Integer; const Value: Cardinal);
    procedure Setmarkup_percent(Tag: Integer; const Value: Cardinal);
    procedure Setmeasure_count(Tag: Integer; const Value: Cardinal);
    procedure Setmeasure_title(Tag: Integer; const Value: string);
    procedure Setmeasure_fractional(Tag: Integer; const Value: Boolean);
  strict protected
    function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
    procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
  public
    constructor Create; override;
    destructor Destroy; override;

    property article: string index tag_article read Farticle write Setarticle;
    property barcode: string index tag_barcode read Fbarcode write Setbarcode;
    property description: string index tag_description read Fdescription write Setdescription;
    property purchase_price: TMoney read Fpurchase_price;
    property sell_price: TMoney read Fsell_price;
    property discount_percent: Cardinal index tag_discount_percent read Fdiscount_percent write Setdiscount_percent;
    property discount_sum: TMoney read Fdiscount_sum;
    property markup_percent: Cardinal index tag_markup_percent read Fmarkup_percent write Setmarkup_percent;
    property markup_sum: TMoney read Fmarkup_sum;
    property taxesList: TProtoBufClassList<TTax> read FtaxesList;
    property measure_count: Cardinal index tag_measure_count read Fmeasure_count write Setmeasure_count;
    property measure_title: string index tag_measure_title read Fmeasure_title write Setmeasure_title;
    property measure_fractional: Boolean index tag_measure_fractional read Fmeasure_fractional write Setmeasure_fractional;
  end;

  TElement = class(TAbstractProtoBufClass)
  public
    const tag_type = 1;
    const tag_title = 3;
    const tag_parent_group_id = 4;
    const tag_id = 5;
    const tag_item = 6;
  strict private
    Ftype: TElementTypeEnum;
    Ftitle: string;
    Fparent_group_id: UInt64;
    Fid: UInt64;
    Fitem: TItem;

    procedure Settype(Tag: Integer; const Value: TElementTypeEnum);
    procedure Settitle(Tag: Integer; const Value: string);
    procedure Setparent_group_id(Tag: Integer; const Value: UInt64);
    procedure Setid(Tag: Integer; const Value: UInt64);
  strict protected
    function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
    procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
  public
    constructor Create; override;
    destructor Destroy; override;

    property &type: TElementTypeEnum index tag_type read Ftype write Settype;
    property title: string index tag_title read Ftitle write Settitle;
    property parent_group_id: UInt64 index tag_parent_group_id read Fparent_group_id write Setparent_group_id;
    property id: UInt64 index tag_id read Fid write Setid;
    property item: TItem read Fitem;
  end;

  TNomenclatureResponse = class(TAbstractProtoBufClass)
  public
    const tag_version = 1;
    const tag_created_time = 2;
    const tag_elementsList = 3;
    const tag_result = 4;
  strict private
    Fversion: Cardinal;
    Fcreated_time: TDateTime;
    FelementsList: TProtoBufClassList<TElement>;
    Fresult: TNomenclatureResultTypeEnum;

    procedure Setversion(Tag: Integer; const Value: Cardinal);
    procedure Setresult(Tag: Integer; const Value: TNomenclatureResultTypeEnum);
  strict protected
    function LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean; override;
    procedure SaveFieldsToBuf(ProtoBuf: TProtoBufOutput); override;
  public
    constructor Create; override;
    destructor Destroy; override;

    property version: Cardinal index tag_version read Fversion write Setversion;
    property created_time: TDateTime read Fcreated_time;
    property elementsList: TProtoBufClassList<TElement> read FelementsList;
    property result: TNomenclatureResultTypeEnum index tag_result read Fresult write Setresult;
  end;

implementation

{ TNomenclatureRequest }

constructor TNomenclatureRequest.Create;
begin
  inherited;
  RegisterRequiredField(tag_current_version);
end;

destructor TNomenclatureRequest.Destroy;
begin
  inherited;
end;

function TNomenclatureRequest.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
  Result := inherited;
  if Result then
    Exit;
  Result := True;
  case FieldNumber of
    tag_current_version:
      current_version := ProtoBuf.readUInt32;
  else
    Result := False;
  end;
end;

procedure TNomenclatureRequest.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
  inherited;
  if FieldHasValue[tag_current_version] then
    ProtoBuf.writeUInt32(tag_current_version, Fcurrent_version);
end;

procedure TNomenclatureRequest.Setcurrent_version(Tag: Integer; const Value: Cardinal);
begin
  Fcurrent_version:= Value;
  FieldHasValue[Tag]:= True;
end;

{ TTax }

constructor TTax.Create;
begin
  inherited;
  RegisterRequiredField(tag_taxation_type);
  RegisterRequiredField(tag_tax_type);
  RegisterRequiredField(tag_tax_percent);
end;

destructor TTax.Destroy;
begin
  inherited;
end;

function TTax.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
begin
  Result := inherited;
  if Result then
    Exit;
  Result := True;
  case FieldNumber of
    tag_taxation_type:
      taxation_type := ProtoBuf.readUInt32;
    tag_tax_type:
      tax_type := ProtoBuf.readUInt32;
    tag_tax_percent:
      tax_percent := ProtoBuf.readUInt32;
  else
    Result := False;
  end;
end;

procedure TTax.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
begin
  inherited;
  if FieldHasValue[tag_taxation_type] then
    ProtoBuf.writeUInt32(tag_taxation_type, Ftaxation_type);
  if FieldHasValue[tag_tax_type] then
    ProtoBuf.writeUInt32(tag_tax_type, Ftax_type);
  if FieldHasValue[tag_tax_percent] then
    ProtoBuf.writeUInt32(tag_tax_percent, Ftax_percent);
end;

procedure TTax.Settaxation_type(Tag: Integer; const Value: Cardinal);
begin
  Ftaxation_type:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TTax.Settax_type(Tag: Integer; const Value: Cardinal);
begin
  Ftax_type:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TTax.Settax_percent(Tag: Integer; const Value: Cardinal);
begin
  Ftax_percent:= Value;
  FieldHasValue[Tag]:= True;
end;

{ TItem }

constructor TItem.Create;
begin
  inherited;
  Fpurchase_price := TMoney.Create;
  RegisterRequiredField(tag_purchase_price);
  Fsell_price := TMoney.Create;
  RegisterRequiredField(tag_sell_price);
  Fdiscount_sum := TMoney.Create;
  Fmarkup_sum := TMoney.Create;
  FtaxesList := TProtoBufClassList<TTax>.Create;
end;

destructor TItem.Destroy;
begin
  Fpurchase_price.Free;
  Fsell_price.Free;
  Fdiscount_sum.Free;
  Fmarkup_sum.Free;
  FtaxesList.Free;
  inherited;
end;

function TItem.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
  tmpBuf: TProtoBufInput;
begin
  Result := inherited;
  if Result then
    Exit;
  Result := True;
  tmpBuf:= nil;
  try
    case FieldNumber of
      tag_article:
        article := ProtoBuf.readString;
      tag_barcode:
        barcode := ProtoBuf.readString;
      tag_description:
        description := ProtoBuf.readString;
      tag_purchase_price:
        begin
          tmpBuf := ProtoBuf.ReadSubProtoBufInput;
          Fpurchase_price.LoadFromBuf(tmpBuf);
        end;
      tag_sell_price:
        begin
          tmpBuf := ProtoBuf.ReadSubProtoBufInput;
          Fsell_price.LoadFromBuf(tmpBuf);
        end;
      tag_discount_percent:
        discount_percent := ProtoBuf.readUInt32;
      tag_discount_sum:
        begin
          tmpBuf := ProtoBuf.ReadSubProtoBufInput;
          Fdiscount_sum.LoadFromBuf(tmpBuf);
        end;
      tag_markup_percent:
        markup_percent := ProtoBuf.readUInt32;
      tag_markup_sum:
        begin
          tmpBuf := ProtoBuf.ReadSubProtoBufInput;
          Fmarkup_sum.LoadFromBuf(tmpBuf);
        end;
      tag_taxesList:
        FtaxesList.AddFromBuf(ProtoBuf, fieldNumber);
      tag_measure_count:
        measure_count := ProtoBuf.readUInt32;
      tag_measure_title:
        measure_title := ProtoBuf.readString;
      tag_measure_fractional:
        measure_fractional := ProtoBuf.readBoolean;
    else
      Result := False;
    end;
  finally
    tmpBuf.Free
  end;
end;

procedure TItem.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
  tmpBuf: TProtoBufOutput;
begin
  inherited;
  tmpBuf:= TProtoBufOutput.Create;
  try
    if FieldHasValue[tag_article] then
      ProtoBuf.writeString(tag_article, Farticle);
    if FieldHasValue[tag_barcode] then
      ProtoBuf.writeString(tag_barcode, Fbarcode);
    if FieldHasValue[tag_description] then
      ProtoBuf.writeString(tag_description, Fdescription);
    if FieldHasValue[tag_purchase_price] then
      SaveMessageFieldToBuf(Fpurchase_price, tag_purchase_price, tmpBuf, ProtoBuf);
    if FieldHasValue[tag_sell_price] then
      SaveMessageFieldToBuf(Fsell_price, tag_sell_price, tmpBuf, ProtoBuf);
    if FieldHasValue[tag_discount_percent] then
      ProtoBuf.writeUInt32(tag_discount_percent, Fdiscount_percent);
    if FieldHasValue[tag_discount_sum] then
      SaveMessageFieldToBuf(Fdiscount_sum, tag_discount_sum, tmpBuf, ProtoBuf);
    if FieldHasValue[tag_markup_percent] then
      ProtoBuf.writeUInt32(tag_markup_percent, Fmarkup_percent);
    if FieldHasValue[tag_markup_sum] then
      SaveMessageFieldToBuf(Fmarkup_sum, tag_markup_sum, tmpBuf, ProtoBuf);
    if FieldHasValue[tag_taxesList] then
      FtaxesList.SaveToBuf(ProtoBuf, tag_taxesList);
    if FieldHasValue[tag_measure_count] then
      ProtoBuf.writeUInt32(tag_measure_count, Fmeasure_count);
    if FieldHasValue[tag_measure_title] then
      ProtoBuf.writeString(tag_measure_title, Fmeasure_title);
    if FieldHasValue[tag_measure_fractional] then
      ProtoBuf.writeBoolean(tag_measure_fractional, Fmeasure_fractional);
  finally
    tmpBuf.Free
  end;
end;

procedure TItem.Setarticle(Tag: Integer; const Value: string);
begin
  Farticle:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TItem.Setbarcode(Tag: Integer; const Value: string);
begin
  Fbarcode:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TItem.Setdescription(Tag: Integer; const Value: string);
begin
  Fdescription:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TItem.Setdiscount_percent(Tag: Integer; const Value: Cardinal);
begin
  Fdiscount_percent:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TItem.Setmarkup_percent(Tag: Integer; const Value: Cardinal);
begin
  Fmarkup_percent:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TItem.Setmeasure_count(Tag: Integer; const Value: Cardinal);
begin
  Fmeasure_count:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TItem.Setmeasure_title(Tag: Integer; const Value: string);
begin
  Fmeasure_title:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TItem.Setmeasure_fractional(Tag: Integer; const Value: Boolean);
begin
  Fmeasure_fractional:= Value;
  FieldHasValue[Tag]:= True;
end;

{ TElement }

constructor TElement.Create;
begin
  inherited;
  RegisterRequiredField(tag_type);
  RegisterRequiredField(tag_title);
  RegisterRequiredField(tag_id);
  Fitem := TItem.Create;
end;

destructor TElement.Destroy;
begin
  Fitem.Free;
  inherited;
end;

function TElement.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
  tmpBuf: TProtoBufInput;
begin
  Result := inherited;
  if Result then
    Exit;
  Result := True;
  tmpBuf:= nil;
  try
    case FieldNumber of
      tag_type:
        &type := TElementTypeEnum(ProtoBuf.readEnum);
      tag_title:
        title := ProtoBuf.readString;
      tag_parent_group_id:
        parent_group_id := ProtoBuf.readInt64;
      tag_id:
        id := ProtoBuf.readInt64;
      tag_item:
        begin
          tmpBuf := ProtoBuf.ReadSubProtoBufInput;
          Fitem.LoadFromBuf(tmpBuf);
        end;
    else
      Result := False;
    end;
  finally
    tmpBuf.Free
  end;
end;

procedure TElement.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
  tmpBuf: TProtoBufOutput;
begin
  inherited;
  tmpBuf:= TProtoBufOutput.Create;
  try
    if FieldHasValue[tag_type] then
      ProtoBuf.writeInt32(tag_type, Integer(Ftype));
    if FieldHasValue[tag_title] then
      ProtoBuf.writeString(tag_title, Ftitle);
    if FieldHasValue[tag_parent_group_id] then
      ProtoBuf.writeInt64(tag_parent_group_id, Fparent_group_id);
    if FieldHasValue[tag_id] then
      ProtoBuf.writeInt64(tag_id, Fid);
    if FieldHasValue[tag_item] then
      SaveMessageFieldToBuf(Fitem, tag_item, tmpBuf, ProtoBuf);
  finally
    tmpBuf.Free
  end;
end;

procedure TElement.Settype(Tag: Integer; const Value: TElementTypeEnum);
begin
  Ftype:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TElement.Settitle(Tag: Integer; const Value: string);
begin
  Ftitle:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TElement.Setparent_group_id(Tag: Integer; const Value: UInt64);
begin
  Fparent_group_id:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TElement.Setid(Tag: Integer; const Value: UInt64);
begin
  Fid:= Value;
  FieldHasValue[Tag]:= True;
end;

{ TNomenclatureResponse }

constructor TNomenclatureResponse.Create;
begin
  inherited;
  RegisterRequiredField(tag_version);
  Fcreated_time := TDateTime.Create;
  FelementsList := TProtoBufClassList<TElement>.Create;
  RegisterRequiredField(tag_result);
end;

destructor TNomenclatureResponse.Destroy;
begin
  Fcreated_time.Free;
  FelementsList.Free;
  inherited;
end;

function TNomenclatureResponse.LoadSingleFieldFromBuf(ProtoBuf: TProtoBufInput; FieldNumber: Integer; WireType: Integer): Boolean;
var
  tmpBuf: TProtoBufInput;
begin
  Result := inherited;
  if Result then
    Exit;
  Result := True;
  tmpBuf:= nil;
  try
    case FieldNumber of
      tag_version:
        version := ProtoBuf.readUInt32;
      tag_created_time:
        begin
          tmpBuf := ProtoBuf.ReadSubProtoBufInput;
          Fcreated_time.LoadFromBuf(tmpBuf);
        end;
      tag_elementsList:
        FelementsList.AddFromBuf(ProtoBuf, fieldNumber);
      tag_result:
        result := TNomenclatureResultTypeEnum(ProtoBuf.readEnum) = RESULT_TYPE_OK;
    else
      Result := False;
    end;
  finally
    tmpBuf.Free
  end;
end;

procedure TNomenclatureResponse.SaveFieldsToBuf(ProtoBuf: TProtoBufOutput);
var
  tmpBuf: TProtoBufOutput;
begin
  inherited;
  tmpBuf:= TProtoBufOutput.Create;
  try
    if FieldHasValue[tag_version] then
      ProtoBuf.writeUInt32(tag_version, Fversion);
    if FieldHasValue[tag_created_time] then
      SaveMessageFieldToBuf(Fcreated_time, tag_created_time, tmpBuf, ProtoBuf);
    if FieldHasValue[tag_elementsList] then
      FelementsList.SaveToBuf(ProtoBuf, tag_elementsList);
    if FieldHasValue[tag_result] then
      ProtoBuf.writeInt32(tag_result, Integer(Fresult));
  finally
    tmpBuf.Free
  end;
end;

procedure TNomenclatureResponse.Setversion(Tag: Integer; const Value: Cardinal);
begin
  Fversion:= Value;
  FieldHasValue[Tag]:= True;
end;

procedure TNomenclatureResponse.Setresult(Tag: Integer; const Value: TNomenclatureResultTypeEnum);
begin
  Fresult:= Value;
  FieldHasValue[Tag]:= True;
end;

end.
